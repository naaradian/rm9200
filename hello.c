/**********************************************************************
*    This file was generated by Design Tool a product of: 
*       ARC International  
*       http://www.ARC.com/         
*                              
*       Fri Jun 08 11:29:32 2007
*   
*       Copyright (c) ARC International  
*       All rights reserved    
*   
*       This software embodies materials and concepts which are
*       confidential to ARC International and is made
*       available solely pursuant to the terms of a written license
*       agreement with ARC International.
*   
*   ********************************************************************/
/* 
*  Resources  -   Number -  Memory Required
*  Kernel       -   N/A       -  N/A
*  Tasks        - 1       -  N/A
*  Msg Pools    -  0 of 16  -   N/A
*  Msg Queues   -  0 of 128   -  N/A
*  Mutexes       -  0    -  N/A
*  Semaphores   -  0 of 0     -   0x00
*  Events       -  0 of 0      -  0x00
*  Logs         -  1 of 16    -  N/A
*  	   Total:  N/A
*/ 
//#include <mqx_prv.h>
#include <mqx.h>
#include <bsp.h>
#include <log.h>
#include <klog.h>
#include <rtcs.h>
#include <enet.h>
#include "hello7.h"

#ifdef USE_HTTP
#include "httpd.h"
#include "tfs.h"
#include "tfs_data.c"
//#include "tfs_data_is_as.c"

#ifndef PROG_MD310_SATI
#ifndef PROG_PU_MSAT
#include "cgi.c"
#endif
#endif




#ifdef PROG_PU_MSAT
#include "cgi_pu_msat.c"
#endif

#ifdef PROG_MD310_SATI
#include "cgi_md100se.c"
#endif



#endif  //USE_HTTP

//#include <mqx_prv.h>

#ifdef CLOCK_ENABLED
extern void UpdateClock(void);
#endif

unsigned char read_flag;
unsigned long writeid_counter;

extern void BlinkLED(long , long );
extern char IsXilWrited(void);
extern void SetBufferState(unsigned long);
extern void EnableInterrupts(void);
extern char CheckDone(void);
extern void Support_Ethernet_10MBit(void);
extern void Set_enet_local0(uchar *);
extern void my_printf(unsigned char);
extern void ChangeTestMode(void);
//extern void ReadDevId(void);
extern unsigned char ReadDevId(unsigned char);
extern unsigned char ReadDevId2(unsigned char);
extern void ClearNvram(void);
extern  void  m_Test_PKU(void);
extern void  m_Load_Xil_Reg();
extern void  m_uart_monitor(void);
extern void  m_usart1_init(void);
extern void  m_usart0_init(void);
extern void  m_usart3_init(void);
extern void  m_usart2_init(void);


extern void usart_select (char);
extern  void m_get_clk (void);   //get clocks to xilinx
extern  void NVRAM_TEST(void);
extern void Init_BMD155(void);
extern void  _irq3_isr(pointer);
extern void  _irq2_isr(pointer);
extern void  _irq1_isr(pointer);
extern void  _irq0_isr(pointer);
extern void  _fiq_isr(pointer);
extern void  _spu_isr(pointer);
extern void   m_cs_init(void);
extern void   m_spi_init(void);
extern void AT91F_DataflashPrintInfo(void);
extern int  AT91F_DataflashInit (void);
extern int  AT91F_DataflashInitx (void);

extern void  AT91F_DataflashCheck (void);
extern void Devise(void);
extern void wd_init(void);
extern void InitClass(void);
extern void m_load_xilinx(void);
extern void m_load_xilinx1(char , char);
extern void m_load_xilinx_IO(void);
extern void m_init_remote_usart1(void);
extern void m_init_remote_usart0(void);
extern void m_init_remote_usart3(void);
extern void m_init_remote_usart2(void);

extern void m_init_remote_snmp(void);
extern uint_32 GetIP();

#ifdef HAVE_GATEWAY
extern uint_32 GetNetwork();
extern uint_32 GetNetMask();
#endif

extern void EmbInit(void);
extern void ktvm_init(void);
extern void mf20_init(void);
extern void TUTS_init(void);
extern void mf20(void);
extern void Enet_is_not_init(void);
extern void FillXilFileData(char);

extern void FillProgVersion(void);

#ifdef  PROG_BMDN
extern void FillConfigFileVersion(void);
extern void FillXilFileDatax(char);
#endif //PROG_BMDN

#ifdef	PROG_PRM_PCH_DEM_XIL_CHN_DMU4 
extern "C" void FillDecFileData(void);
#endif


boolean TFTPSRV_access(char_ptr filename,uint_16 op) {return TRUE;}
//160823char                 buff[20000l];  //need check

#ifdef USE_SOCKETSD	

//#define  BUFF_SIZE_DATAG  10000l
char                 buff[BUFF_SIZE_DATAG];  //need check
//#define  BUFF_SIZE_DATAGt  10000l
char                 buff_udpt[BUFF_SIZE_DATAG];  //need check
//char*                 pbuff_udpt;
unsigned long             len_udpt;
unsigned long   flag_send_udp_asu;

#endif

#ifdef USE_SOCKETSD_485	
char                 buff_485[BUFF_SIZE_DATAG];  //need check
char                 buff_udpt_485[BUFF_SIZE_DATAG];  //need check
unsigned long             len_udpt_485;
unsigned long   flag_send_udp_asu_485;
#endif





 int_32               numbytes;
uint_32              socket_stream, socket_dgram;
int_32               t_count;
unsigned long        autoneg_counter;
unsigned char t_connect;

//unsigned char send485_enabled;
//char InitFinish;
uint_32 Stephany0;
uint_32 Stephany1;
uint_32 Stephany2;
uint_32 Stephany3; 
uint_32 Stephany4;
//volatile uint_32 Stephany5; 
unsigned long Stephany5; 
uint_32 Stephany6;
uint_32 Stephany7;
uint_32 Stephany8;
uint_32 Stephany9;
uint_32 Stephany10;
uint_32 Stephany11;
uint_32 Stephany12;
uint_32 Stephany13;
uint_32 Stephany14;
unsigned long Stephany19;

uint_32 Stephany9_prev;
unsigned int testclass;
_rtcs_if_handle  ihandle0;
_rtcs_if_handle  ihandle1;

uint_32 OldIP;

#ifdef HAVE_GATEWAY
uint_32 OldNetwork;
uint_32 OldNetMask;
#endif

uint_32 TimerCounter;
uint_32 TimerCounter1;
uint_32 TimerEthOff;
uint_32 TimerStartMF20;
uint_32 TimerUSART1Off;

uint_32 DoneWaitCounter;
unsigned long InterruptWatchDog;
unsigned int IntFlag;
extern pointer fh_ptr; //new for serial port
extern pointer fusart1_ptr; //new for serial port
extern pointer fusart0_ptr; //new for serial port
extern pointer fusart3_ptr; //n
extern pointer fusart2_ptr; //n


char * pxilinx;
char * pnvram;
char * pxilinx3;


char_ptr taskname;
int ecount2;
    
 unsigned long data_buffer;       //need init data!!!!!!!!
 unsigned char counter_buffer;   //need init counter!!!!!!
 
 unsigned char errors;
 #ifdef ALL_ADDR
 unsigned long counter_mreceive;
 unsigned long counter_msend;
 #endif //  ALL_ADDR
 
 unsigned long tsee[11];
 
 #ifdef YOURNAL
 unsigned char ev_power_off;
 unsigned long prev_event;
 unsigned char yournal_init;
 unsigned long view_counter;
 #endif //YOURNAL
 
// #ifdef PROG_PRM_PCH_C
 unsigned char start1, start2,start3;
 
#ifdef PRM_PCH_N_RUN_IN_INTERRUPT 
 unsigned char  transfer_flag;
#endif // PRM_PCH_N_RUN_IN_INTERRUPT 

// #endif //PROG_PRM_PCH_C
 unsigned long message;   
 
#ifdef IRQ_LIMITED 
 unsigned long time_irq;
//t 121117#define  LIMIT_IRQ_PERIOD  100
//#define  LIMIT_IRQ_PERIOD  50
#endif //IRQ_LIMITED 

 
#ifdef USART0_TRY_PDC 
 unsigned char last_cnt; //need init at start!!!!!
 unsigned long buff2_cnt; //need init at start!!!!!
 unsigned char flag_pdc0;
 unsigned long counter_int;
 unsigned long counter_int1;
#endif //  USART0_TRY_PDC


#ifdef USART1_TRY_PDC 
 unsigned char flag_pdcu1;
 unsigned long time_pdc_u1, timer;

#endif //  USART1_TRY_PDC

#ifdef USART2_TRY_PDC 
 unsigned char flag_pdcu2;
 unsigned long time_pdc_u2, timer;

#endif //  USART2_TRY_PDC


#ifdef USART0_TRY_PDC_1 
 unsigned char flag_pdcu0;
 unsigned long time_pdc_u0; //, timer;

#endif //  USART0_TRY_PDC_1

#ifdef USART0_TRY_PDC_1T
 unsigned char flag_pdcu0t;
 unsigned long time_pdc_u0t; //, timer;

#endif //  USART0_TRY_PDC_1

#ifdef USART1_TRY_PDC_1T
 unsigned char flag_pdcu1t;
 unsigned long time_pdc_u1t; //, timer;

#endif //  USART1_TRY_PDC_1

#ifdef USART2_TRY_PDC_1T
 unsigned char flag_pdcu2t;
 unsigned long time_pdc_u2t; //, timer;

#endif //  USART2_TRY_PDC_1

#ifdef PROG_BMDN
unsigned long  timer;
//unsigned char fl_start_modem;
#endif //PROG_BMDN

#ifdef PROG_PRM_PCH
unsigned long timewait;
#endif // PROG_PRM_PCH

#ifdef PROG_PRM_PCH_DEM
unsigned long timewait;
#endif // PROG_PRM_PCH


#ifdef 	PROG_PRM_PCH_N
  unsigned char Rej;
  unsigned char Filtr;
#endif //PROG_PRM_PCH_N

#ifdef 	PROG_PRM_PCH_SPI
  unsigned char Rej;
  unsigned char Filtr;
#endif //PROG_PRM_PCH_N




#ifdef 	TEST_RDN
 unsigned long crdn, carp, cip;
#endif //TEST_RDN

#ifdef PROG_ACT155
unsigned char wd_reset_enabled;
#endif //PROG_ACT155


//#ifdef CHECK_ETH_STATE
unsigned long my_IP_OK;
//#endif //CHECK_ETH_STATE

#ifndef DISABLE_ETHERNET

  _enet_handle    enet_handle0;    //100201
  _enet_address   enet_local0;// = {0, 1, 2, 3, 4, 5}; //this is mac!!!!!!!   //100201
   uint_32         rtcs_result;
#endif   
   

/*   Task Code -  hello     */

unsigned char is_servicepack;
  uint_32 speed;
  
#ifdef USE_QUOTE_SERVER  
extern "C" uint_32  QUOTE_SRV_init (char_ptr,uint_32,uint_32);
unsigned long rpac_counter;
#endif //USE_QUOTE_SERVER 
 
#ifdef USE_TCPIP_CLIENT
extern unsigned char q_client_state;
unsigned long q_client_counter;
#endif //USE_TCPIP_CLIENT

#ifdef PRINT_USART_DATA 
unsigned char print_flag;
#endif //  PRINT_USART_DATA

//unsigned long shutdown_cnt;
unsigned int restart_counter; 

unsigned char rnms_was_used; 

#ifdef TRY_UNBLOCK
//unsigned long tcpip_id;
unsigned long snmp_id;
unsigned long rdn_id;
unsigned long rdnt_id;

unsigned long tftp_id;
// KERNEL_DATA_STRUCT_PTR kernel_data;
 //TD_STRUCT_PTR td_ptr;
unsigned long  ul_pointer_bd;
unsigned long  ul_counter_bd;
// ENET_CFG_STRUCT_PTR     enet_ptr;
#endif

unsigned long tcpip_id;
unsigned long  ul_pointer_bd;
unsigned long  ul_counter_bd;
unsigned long  ul_entries;
unsigned long keepmem;
unsigned long keepbuf;
unsigned long keepenet;
unsigned long keeprtcs;
unsigned long keeppool;
unsigned long keepsocket;
unsigned long keeppart;
unsigned long tcpipmsgcnt;

unsigned long keephandle;
unsigned long keephandle2;
unsigned long keephandle3;

unsigned long keep_ip_cfg;

unsigned long status_read;

unsigned char check[5];

 unsigned char start_main_loop;
  unsigned char flag_need_load;
  
#ifdef USE_HTTP
  
 // const HTTPD_ROOT_DIR_STRUCT root_dir[] = {
  HTTPD_ROOT_DIR_STRUCT root_dir[] = {
    { "", "tfs:" },
    { 0, 0 }
};
#endif //use_http - hier size only need init in task
 extern  unsigned long ipe_test_counter;
 unsigned long lock_counter;
 
 unsigned char flag_restart_web_prog;
 unsigned long counter_restart_web_prog;
                                        


/*TASK---------------------------------------------------------------
*
* Task Name   :  hello
* Comments    :  
*
*END*--------------------------------------------------------------*/

void hello
   (
      uint_32  parameter
   )
{
   EmbInit(); // init buffer pointers before all!!!!!!
flag_restart_web_prog = 0;

ipe_test_counter = 0;
read_flag = 0;
writeid_counter = 0;
lock_counter = 0;


#ifdef USE_HTTP
 
//#include "tfs_data.c"
//#include "tfs_data_is_as.c"
//#include "cgi.c"

    HTTPD_STRUCT *server;
 //   extern const HTTPD_CGI_LINK_STRUCT cgi_lnk_tbl[];
//    extern const TFS_DIR_ENTRY tfs_data[];
 //   extern const TFS_DIR_ENTRY tfs_data[];
 //   TFS_DIR_ENTRY tfs_data[];
    HTTPD_PARAMS_STRUCT *params;
#endif // USE_HTTP

 flag_need_load = 1;
   start_main_loop = 0;
check[0] = check[1] =check[2] =check[3] =check[4] = 0; 
char tcp_name[] = "TCP/IP";
char * name_ptr = tcp_name;

rnms_was_used = 0;
tcpipmsgcnt = 0;


#ifdef PRINT_USART_DATA 
 print_flag = 0;
#endif //  PRINT_USART_DATA


//shutdown_cnt = 0;

#ifdef PROG_BMDN
 timer = 0;
// fl_start_modem = 0;
#endif //PROG_BMDN




#ifdef USE_TCPIP_CLIENT
 q_client_state = 0;
 q_client_counter = 0;
#endif //USE_TCPIP_CLIENT

#ifdef USE_QUOTE_SERVER  
 rpac_counter = 0l;
#endif //USE_QUOTE_SERVER 




speed = 0;
is_servicepack = 0;

#ifdef CHECK_ETH_STATE
my_IP_OK = 0;
#endif //CHECK_ETH_STATE

#ifdef 	TEST_RDN
  crdn = carp = cip = 0;
#endif //TEST_RDN



#ifdef 	PROG_PRM_PCH_N
   Rej = 0;
   Filtr = 0;
#endif //PROG_PRM_PCH_N


#ifdef USART0_TRY_PDC 
 last_cnt = 0; //need init at start!!!!!
 buff2_cnt = 0; //need init at start!!!!!
 flag_pdc0 = 1;
 // flag_pdc0 = 0;
 counter_int = 0;
 counter_int1 = 0;
#endif //  USART0_TRY_PDC

#ifdef IRQ_LIMITED 
 time_irq = 0;
#endif //IRQ_LIMITED 


#ifdef USART1_TRY_PDC 
//101201 unsigned char flag_pdcu1 = 0;
       flag_pdcu1 = 0;
       time_pdc_u1 = 0;
       timer = 0;
#endif //  USART1_TRY_PDC

#ifdef USART2_TRY_PDC 
//101201  unsigned char flag_pdcu2 = 0;
      flag_pdcu2 = 0;
       time_pdc_u2 = 0;
       timer = 0;
#endif //  USART1_TRY_PDC





#ifdef USART0_TRY_PDC_1 
//101201 unsigned char flag_pdcu0 = 0;
       flag_pdcu0 = 0;
       time_pdc_u0 = 0;
    //   timer = 0;
#endif //  USART0_TRY_PDC_1

#ifdef USART0_TRY_PDC_1T
//101201unsigned char flag_pdcu0t = 0;
       flag_pdcu0t = 0;
       time_pdc_u0t = 0;
    //   timer = 0;
#endif //  USART0_TRY_PDC_1

#ifdef USART1_TRY_PDC_1T
//101201unsigned char flag_pdcu1t = 0;
       flag_pdcu1t = 0;
       time_pdc_u1t = 0;
    //   timer = 0;
#endif //  USART0_TRY_PDC_1

//#ifdef USART1_TRY_PDC_2T
#ifdef USART2_TRY_PDC_1T
//101201unsigned char flag_pdcu2t = 0;
      flag_pdcu2t = 0;
       time_pdc_u2t = 0;
    //   timer = 0;
#endif //  USART0_TRY_PDC_1







  message = 0;
//100201  uint_32         rtcs_result;
//100201  _enet_handle    enet_handle0;
//100201  _enet_address   enet_local0 = {0, 1, 2, 3, 4, 5}; //this is mac!!!!!!!
//100201  enet_local0 = {0, 1, 2, 3, 4, 5}; //this is mac!!!!!!!  //100201

#if  KERNEL_LOG_ENABLED
  _mqx_uint       log_result;
#endif // KERNEL_LOG_ENABLED 

 #ifdef ALL_ADDR
 counter_mreceive = 0l;
 counter_msend = 0l;
 #endif // ALL_ADDR
 
 #ifdef YOURNAL
 ev_power_off = 0;
 prev_event = 0l;
 yournal_init = 0l;
 view_counter = 1;
 #endif //YOURNAL   
 
 




autoneg_counter = 0;
errors = 0;
 data_buffer = 0l;;       //need init data!!!!!!!!
 counter_buffer = 0;;   //need init counter!!!!!!


  ecount2 = 0;

  uint_32         pinger = 0;
  uint_32         cnt = 0;//, State,tg;
  uint_32         seldom = 0; 
 // uint_32         tg = 1;
  uint_32         tg = 1<<13;
  char            led = 0;
  
 // send485_enabled = 1;
  
  t_count = 0;
  t_connect = 0;
  uint_32         State = 0x5550000Al;   // as marker start and finish
  uint_32         State1 = 0l;
 // InitFinish = 0;

  Stephany0 = 0l; 
  Stephany1 = 0l; 
  Stephany2 = 0l; 
  Stephany3 = 0l; 
  
  
  Stephany14 = 0l; 
  Stephany11 = 0l;
  Stephany19 = 0l;
  TimerStartMF20 = 0l;
  DoneWaitCounter = 0l;
  InterruptWatchDog = 0l;
  pnvram  = (char*)(0x10000000);
  pxilinx = (char*)(0x30000000);
   pxilinx3 = (char*)(0x40000000);
  TimerCounter = 0l;
  TimerCounter1 = 0l;
  TimerUSART1Off = 0l;
  
//______________________________________________________________________
     AT91RM9200_AIC_REG_STRUCT_PTR aic_ptr = 
                                  (AT91RM9200_AIC_REG_STRUCT_PTR)AT91RM9200_AIC_BASE;
     AT91RM9200_PIO_REG_STRUCT_PTR pio_ptr1;
       AT91RM9200_PIO_REG_STRUCT_PTR pio_ptrb;

     AT91RM9200_PMC_REG_STRUCT_PTR  pmc_ptr;
     pmc_ptr = (AT91RM9200_PMC_REG_STRUCT_PTR) AT91RM9200_PMC_BASE;
 //  pmc_ptr->PCER =  (1 << AT91RM9200_PIOB_PID) ;
#ifndef PROG_TUTS
     pmc_ptr->PCER =  (1 << AT91RM9200_PIOB_PID) | (1 << AT91RM9200_PIOC_PID);
#else //  PROG_TUTS
       pmc_ptr->PCER =  (1 << AT91RM9200_PIOB_PID) | (1 << AT91RM9200_PIOC_PID) | (1 << AT91RM9200_PIOA_PID);

#endif //PROG_TUTS    
//get off to load xilinx     pio_ptr = (AT91RM9200_PIO_REG_STRUCT_PTR) AT91RM9200_PIOB_BASE;
     pio_ptr1 = (AT91RM9200_PIO_REG_STRUCT_PTR) AT91RM9200_PIOC_BASE;
     pio_ptrb =  (AT91RM9200_PIO_REG_STRUCT_PTR) AT91RM9200_PIOB_BASE;

//________________________________________________________________________________________toggle_io
// 
#ifdef	PROG_DMU6 

    _at91rm9200_pio_set(AT91RM9200_PIO_PORT_B, 0, AT91RM9200_PIO_PERIPHERAL_IO, 1);
      pio_ptrb->CODR = 1<<0; //temporary!!! set to zero
  //    pio_ptrb->SODR = 1<<0; // set to one   160915
      _at91rm9200_pio_set(AT91RM9200_PIO_PORT_A, 5, AT91RM9200_PIO_PERIPHERAL_A, 0);   //spi cs2

 #endif    
 BlinkLED(20, 1);  
  
  
     _at91rm9200_pio_set(AT91RM9200_PIO_PORT_C, 13, AT91RM9200_PIO_PERIPHERAL_IO, 1);
     
     
     
     
//__________________________________________________________________________________________irq
//BlinkLED(20, 5);   
  
//___________________________________________________________Sockets
#ifdef USE_SOCKETS
sockaddr_in laddr, raddr;
uint_32 sock, listensock;
//int_32 length;
//uint_32 index;
uint_32 error;
uint_16 rlen;
char SockBuff[SIZE_SOCK_BUFF];
strcpy(&SockBuff[0], "Hello from MQX!");
#endif //USE_SOCKETS

#ifdef USE_SOCKETSD


unsigned long Old_TTL; 
unsigned long * pTTL;

unsigned long New_TTL; 

sockaddr_in raddrd;//, laddrd;

uint_32 sockd, listensockd;
//int_32 length;
//uint_32 index;
uint_32 errord;
uint_16 rlend;
//uint_32  flag_send_udp_asu;


//char SockBuffd[SIZE_SOCK_BUFFD];


//strcpy(&SockBuffd[0], "Hello from MQX!");

  

//int_32 socklist[2];
int_32 socklist[1];
sockaddr_in local_sin;
uint_32 result;
uint_32 lengthd;
//sockaddr_in remote_sin; 

// IP_CFG_STRUCT_PTR IP_cfg_ptr = RTCS_getcfg(IP);

#endif //USE_SOCKETSD


#ifdef USE_SOCKETSD_485
unsigned long Old_TTL_485; 
unsigned long * pTTL_485;
unsigned long New_TTL_485; 
sockaddr_in raddrd_485;//, laddrd;
uint_32 sockd_485, listensockd_485;
uint_32 errord_485;
uint_16 rlend_485;
int_32 socklist_485[1];
sockaddr_in local_sin_485;
uint_32 result_485;
uint_32 lengthd_485;
#endif //USE_SOCKETSD






#ifndef NO_USE_WD
  wd_init();
#endif

 cashe_off();

//#ifndef TEST_MAKET  
   //____________________________________________
//init buffers
 m_init_remote_usart1();  
 m_init_remote_usart0(); 
 m_init_remote_usart3();   
 m_init_remote_usart2();
 m_init_remote_snmp(); 
 //_____________________________________

//_____________________________________________________________ockets
  m_cs_init();  //1              //cs for storage before class to can read data for class
//_______________________________________________________________
// EmbInitNVRAM(); //081208  
#ifdef PROG_PU_MSAT	
#ifndef	PROG_VNV1
   ResetPult();
#endif   
#endif  

#ifdef PROG_MD310_SATI	
#ifndef MAKET_PLATA
   ResetPult();
#endif   
#endif   
 
 
// BlinkLED(100, 2); 
 // for(;;);
//
  InitClass();  //2
#ifndef PROG_TUTS     
//to usart2     _at91rm9200_pio_set(AT91RM9200_PIO_PORT_A, 23, AT91RM9200_PIO_PERIPHERAL_B, 0); // irq3
     _at91rm9200_pio_set(AT91RM9200_PIO_PORT_A, 25, AT91RM9200_PIO_PERIPHERAL_B, 0); // irq2
     _at91rm9200_pio_set(AT91RM9200_PIO_PORT_A, 26, AT91RM9200_PIO_PERIPHERAL_B, 0); // irq1
     _at91rm9200_pio_set(AT91RM9200_PIO_PORT_B, 29, AT91RM9200_PIO_PERIPHERAL_A, 0); // irq0
//     _at91rm9200_pio_set(AT91RM9200_PIO_PORT_B, 29, AT91RM9200_PIO_PERIPHERAL_B, 0); // may be perpirealb //b29 set as input of irq0 
     _at91rm9200_pio_set(AT91RM9200_PIO_PORT_B, 28, AT91RM9200_PIO_PERIPHERAL_A, 0); // fiq 
//110222:     
     _at91rm9200_pio_set(AT91RM9200_PIO_PORT_B, 5, AT91RM9200_PIO_PERIPHERAL_IO, 0); //110222    //line done

#endif // no PROG_TUTS     


//__________________________________________________________________________________________spi  
     aic_ptr->SPU = (uint_32)_spu_isr;    // address of spurions interrupt
     for(cnt = 0l; cnt < 32l; cnt++){ /* Body */
       aic_ptr->EOICR = 0xFF; 
      } 
//___________________________ok      
// BlinkLED(500, 3); 
//  for(;;);
//___________________________     
      
      
      
#ifndef TEST_MAKET  
      
 /* create kernel log  */
#if  KERNEL_LOG_ENABLED
      log_result = _klog_create((_mqx_uint)40000, (uint_32)LOG_OVERWRITE);
 //  if (log_result != MQX_OK)
 //     {
 //     }
   _klog_control((uint_32)0xffffffff, FALSE);
   _klog_control(KLOG_ENABLED |
                 KLOG_FUNCTIONS_ENABLED |
                 KLOG_INTERRUPTS_ENABLED |
                 KLOG_SYSTEM_CLOCK_INT_ENABLED |
                 KLOG_CONTEXT_ENABLED |
                 KLOG_TASKING_FUNCTIONS |
                 KLOG_ERROR_FUNCTIONS |
                 KLOG_MESSAGE_FUNCTIONS |
                 KLOG_INTERRUPT_FUNCTIONS |
                 KLOG_MEMORY_FUNCTIONS |
                 KLOG_TIME_FUNCTIONS |
                 KLOG_EVENT_FUNCTIONS |
                 KLOG_NAME_FUNCTIONS |
                 KLOG_MUTEX_FUNCTIONS |
                 KLOG_SEMAPHORE_FUNCTIONS |
                 KLOG_WATCHDOG_FUNCTIONS, TRUE);
#endif //MY_ENABLE_KERNEL_LOG                 
//______________________________________ 
 AT91F_DataflashInit ();
 
 
 #ifdef	PROG_DMU6 

   // _at91rm9200_pio_set(AT91RM9200_PIO_PORT_B, 0, AT91RM9200_PIO_PERIPHERAL_IO, 1);
   //   pio_ptrb->CODR = 1<<0; //temporary!!! set to zero
      pio_ptrb->SODR = 1<<0; // set to one
#endif    

//to not view  AT91F_DataflashPrintInfo ();
 //AT91F_DataflashCheck ();
//___________________________________________
//cashe_off();

#ifdef	PROG_PRM_PCH_DEM_XIL_CHN_DMU4 
#ifndef PROG_VNV1
 FillDecFileData();
#endif 
#endif 



#ifndef 	PROG_PRM_PCH_DEM_XIL
   FillXilFileData((char)XILINXPG);   //after init flsh make this
#else
   FillXilFileData((char)XILINXPG1);   //after init flsh make this
#endif   
   
   FillProgVersion();
   
   
#ifndef TESTSTART   
   
   ReadDevId(0);
   
#ifdef TEST_POK
 WritePOK(0l);
#endif 

   
#ifndef	 PROG_PRM_PCH_SPI_ETH_UART    
#ifdef PROG_PRM_PCH_L_61  
   ReadDevId2(0);
#endif 

#ifdef	 PROG_PRM_PCH_SPI_XIL_ETH
#ifndef PROG_VNV1

   ReadDevId2(0);
#endif   
#endif
#endif
   
//cashe_on();
   
//______________________________________________________
#ifdef PROG_PU_MSAT
#ifndef MAKET_PLATA
#ifndef PROG_ODU1
#ifndef	PROG_VNV1
      
      _at91rm9200_pio_set(AT91RM9200_PIO_PORT_B, 12, AT91RM9200_PIO_PERIPHERAL_IO, 1); //110222    //line done
         pio_ptrb->MDER = 1<<12;
         pio_ptrb->CODR = 1<<12; //get down line prog for xilinx
         
   //   if(GetTestMode() != 0x27)
   //     { 
         delay_mcs(1000000l);
         pio_ptrb->SODR = 1<<12; //get up line prog for xilinx
         delay_mcs(1000000l);
delay_mcs(1000000l);
delay_mcs(1000000l);
delay_mcs(1000000l);
delay_mcs(1000000l);
delay_mcs(1000000l);
     //     }
#endif     
#endif     
#endif     
#endif
   
   
 //ok  SetTestMode(0x8e); //t101117
 
//___________________________ok      
//BlinkLED(1000, 4); 
 // for(;;);
//___________________________     
 
 
   
#ifdef PROG_BMDN
 FillConfigFileVersion();
#endif // PROG_BMDN  

// BlinkLED(50, 5); 
//___________________________ok      
// BlinkLED(1000, 1000); 
 // for(;;);
//___________________________ 


#ifdef 	PROG_PU_MSAT
#ifndef MAKET_PLATA
#ifndef	PROG_VNV1

 FillRadianVersion();
#endif 
#endif
#endif

#ifdef 	PROG_PRM_PCH_DEM
#ifndef	PROG_PRM_PCH_DEM_XIL_CHN_DMU3
#ifndef	PROG_PRM_PCH_DEM_XIL_CHN_DMU4

   LoadDDSs();
#endif   
#endif    
#endif   
   
//__________________________________________
#ifndef PROG_DMU6
#ifndef 	PROG_MD310
//#endif

#ifndef PROG_PU_MSAT
//#ifndef PROG_PRM_PCH_SPI_XIL   //for _xil xilinx is loaded
//#ifndef PROG_PRM_PCH_SPI
//#endif

//m_load_xilinx3((char)XILINXPG, 1); //t 150518

#ifndef PROG_PRM_PCH_DEM_XIL
#ifndef PROG_PRM_PCH_N_1
#ifndef PROG_TUTS 
#ifndef PROG_ODU1
#ifndef WITHOUT_XILINX            //temporary
 // if(IsXilWrited()) //find header to not wait in first init
 

//  if(IsXilWrited())//ok //find header to not wait in first init
 if(1) //IsXilWrited() work not olwais
{

//090515 #ifdef PROG_ACT155N  

 
// check[0] =  CheckDoneShort();
// check[1] =  CheckDoneShort();
// check[2] =  CheckDoneShort();
// check[3] =  CheckDoneShort();
//t check[2] =  3;


 if(GetTestMode() != 0xAA)      //restart from reset button of JackE
// if(1)   //for test
  {
#ifndef  PROG_PU_M710 
#ifndef PROG_COMMUTATOR1 
#ifndef PROG_ODU1
 check[4] =  CheckDoneShort();
// check[2] =  0;
#endif
#endif 
#endif 


#ifdef PROG_ODU1




check[4] =  MirrorTest();
#endif

#ifdef  PROG_PU_M710
 check[4] =  MirrorTest();
 hot_restart = check[4];
//  check[2] =  1;
#endif

#ifdef PROG_COMMUTATOR1 
 check[4] =  MirrorTest();
 hot_restart = check[4];
#endif 

#ifdef PROG_PU_M    //pu_m_e
 check[4] =  MirrorTest();
// hot_restart = check[4];
#endif 


 }
 else
 { /* Body */
   check[4] = 0;
 //    check[2] =  2;

 } /* Endbody */

// if(check[4]) SetTestMode(0x8e); //110218 - if xilinx loaded - do not reload modems!!!
    if(check[4] == 1)
     {
     check[3] = 0x99;
#ifndef PROG_BMDN4 //temporary    
#ifndef PROG_BMDN3 //temporary   
#ifndef PROG_ODU1
 
         SetTestMode((unsigned long)0x8el);
#endif 
#endif  
#endif      
         
     }
     else{ /* Body */
#ifdef PROG_PU_M      
     if(GetTestMode() == 0x8e)    SetTestMode((unsigned long)0x1);
#endif     
     
     
   } /* Endbody */
     
//#ifdef TEST_REMOTE_FF     
//         m_load_xilinx3((char)XILINXPG, 1);
//#endif
  
 // if(!CheckDoneShort())   //090629 NOT RELOAD XILINX IF IT IS LOADED!!!
// if(1)
  if(check[4] == 0)   //090629 NOT RELOAD XILINX IF IT IS LOADED!!!
//090515 #endif //PROG_ACT155N 
{
check[0] = 0x33;
  check[1] = GetTestMode();
  
//#ifndef PROG_PU_M	  
  if(GetTestMode() != 0x8el)  //ok
//#else
// if(1)  //t150518
//#endif
 {
// check[1] = 0x44;
  if(GetTestMode() != 0x27l)  //ok
 {
    check[3] = 0x55;

 
 
 //ok if(1){    //t
//ok  if(1){    //t

 
 //å  for(cnt = 1; cnt <= (uint_32)XIL_LOAD_TRY; cnt++)
   for(cnt = 1; cnt <= (uint_32)XIL_LOAD_TRY; cnt++)
  { 
 //for(;;) //test
   //  *pnvram =  GetTestMode(); //t
   // SetTestMode(0x100); //101117 for test
    check[2] = 0x77;
#ifndef TRY_LOADX   
     m_load_xilinx3((char)XILINXPG, cnt);
#else
   m_load_xilinx3t((char)XILINXPG, cnt);
#endif
   
#ifndef  PROG_PU_M710      
    if(CheckDoneShort()) 
     {
     break;
     }
#else
      break;
#endif
     
     
  } 
 } 
}

}

} //xil_writed

 if(GetTestMode() == 0x27)
  {
   SetTestMode(1l);
  } 
  
  
if(GetTestMode() == 0x5D)
  {
   SetTestMode(1l);
  } 
  
//#ifdef PROG_KAZAH		

//if((ComparePOK(1)))
//  {
//     WritePOK(0x1000);
//  }
//#endif
  
  
  
  
  
  
#endif //PROG_ODU1
#endif //WITHOUT_XILINX
#endif //no PROG_TUTS
#endif // PROG_PRM_PCH_N_1
#endif //	PROG_PRM_PCH_DEM_XIL

//#ifndef PROG_PRM_PCH_SPI_XIL
//#endif
//#endif
#endif

//#ifndef PROG_MD310_SAT
#endif


//#endif
//#endif //no 	PROG_BMDN1
// after loading xilinx  - use spi

#ifdef PROG_MD310_SAT
#ifndef PROG_ODU1

     m_load_xilinx3((char)XILINXPG, 1);
     
#endif     
#endif



#endif    //prog_dmu6


//#ifdef PROG_KAZAH

//     m_load_xilinx3((char)XILINXPG, 1);
     
//#endif


#ifdef PROG_DMU6
     pio_ptrb->SODR = 1<<0; //get up line prog for xilinx
#endif


//BlinkLED(1500, 1); 





if(GetTestMode() == 0x50)
  {
   SetTestMode(1l);
  } 
if(GetTestMode() == 0x5A)
  {
   SetTestMode(1l);
  } 
if(GetTestMode() == 0x22)
  {
   SetTestMode(1l);
  } 
  
  /*
if(GetTestMode() == 0xAA)
  {
   SetTestMode(1l);
  } 
  
 */ 
//#ifdef USE_USART2
// mode5AS = 0;
// Set_Usart2_To_RS485();
// time1old232S = 0l;
// embMsg485RequestS.Init();
//#endif // USE_USART2
  



//#ifdef XIL_FLASH
//121003  AT91F_DataflashInitx(); //hier fall
//121003  FillXilFileDatax(0);
//#endif 

#ifdef PROG_PRM_PCH_SPI_XIL
//t m_get_clk1(); 
m_get_clk1();
#endif

 //get on clock to xilinx 
#ifdef PROG_MF20
 m_get_clk();           
#endif //PROG_MF20 

#endif // TESTSTART 

#ifdef MAKET_PLATA
 m_get_clk();  //temporary for maket
#endif //MAKET_PLATA 

#ifndef  TESTSTART 

#ifdef PROG_PRM_PCH_DEM_XIL_CHN_DMU3
 m_get_clk1();  //temporary for maket
#endif //MAKET_PLATA 

#ifdef PROG_PRM_PCH_DEM_XIL_CHN_DMU4
 m_get_clk1();  //temporary for maket
#endif //MAKET_PLATA 

#ifdef PROG_MD310
 m_get_clk2();  
#endif //MAKET_PLATA 

#ifdef PROG_BMDN6
m_get_clk2();  
#endif //PROG_BMDN6 

#ifndef PROG_PD3   //asi n dmu
 m_get_clk1(); 
#endif


//may be need make it after get clocks?




//_______________________________________ 
#ifndef PROG_TUTS 
#ifdef USE_PULT

#ifdef PROG_MF20
 m_Load_Xil_Reg();
#endif //PROG_MF20


#ifdef MAKET_PLATA
 m_Load_Xil_Reg();   //temporary for maket
#endif //MAKET_PLATA 


#endif //USE_PULT  
#endif // PROG_TUTS


//___________________________ok      
// BlinkLED(1000, 1000); 
//  for(;;);
//___________________________ 


   
   
 //_at91rm9200_st_install_isr(io_init_ptr->VECTOR,
 //     (void (_CODE_PTR_)(pointer))_at91rm9200_dbug_uart_serial_int_isr, 
 //      int_io_dev_ptr);
// _at91rm9200_st_install_isr(AT91RM9200_IRQ2_VECTOR,     //make to timer
//      (void (_CODE_PTR_)(pointer))_irq2_isr, 
//       NULL);


if (_int_install_isr(AT91RM9200_IRQ3_VECTOR,
      (void (_CODE_PTR_)(pointer))_irq3_isr, NULL) == NULL) 
   {  } 
    
if (_int_install_isr(AT91RM9200_IRQ2_VECTOR,
     (void (_CODE_PTR_)(pointer))_irq2_isr, NULL) == NULL) 
  {  }  
if (_int_install_isr(AT91RM9200_IRQ1_VECTOR,
      (void (_CODE_PTR_)(pointer))_irq1_isr, NULL) == NULL) 
   {  }   
if (_int_install_isr(AT91RM9200_IRQ0_VECTOR,
      (void (_CODE_PTR_)(pointer))_irq0_isr, NULL) == NULL) 
   {  }  
if (_int_install_isr(AT91RM9200_FIQ_VECTOR,
      (void (_CODE_PTR_)(pointer))_fiq_isr, NULL) == NULL) 
   {  }  
   
 /*  
 _at91rm9200_st_install_isr(AT91RM9200_IRQ3_VECTOR,     //make to timer
      (void (_CODE_PTR_)(pointer))_irq3_isr, 
       NULL);   
  _at91rm9200_st_install_isr(AT91RM9200_IRQ2_VECTOR,     //make to timer
      (void (_CODE_PTR_)(pointer))_irq2_isr, 
       NULL);  
 _at91rm9200_st_install_isr(AT91RM9200_IRQ1_VECTOR,     //make to timer
      (void (_CODE_PTR_)(pointer))_irq1_isr, 
       NULL);  
 _at91rm9200_st_install_isr(AT91RM9200_IRQ0_VECTOR,     //make to timer
      (void (_CODE_PTR_)(pointer))_irq0_isr, 
       NULL);  
 _at91rm9200_st_install_isr(AT91RM9200_FIQ_VECTOR,     //make to timer
      (void (_CODE_PTR_)(pointer))_fiq_isr, 
       NULL);                         
 */  
 //______________________________________   
  for(cnt = 0l; cnt < 32l; cnt++){ 
     aic_ptr->EOICR = 0xFF; 
     } 
//___________________________________________
   cnt = 0;
//______________________________________________
     
 //___________________________________________  Need after usart init
//#ifndef PROG_TUTS 
//#ifdef USE_PULT 
// m_Test_PKU();
//#endif 
//#endif
 // tChangeTestMode();
 //____________________________________________ 
 // ReadDevId();
  
  
  if(ComparePOK(2))
  {
  WritePOK(0x1000l);
  }
  
  
  
  ChangeTestMode(); // hier can writing dev id!!!
 //______________________________________  
 //____________________________________________ 
 
#ifndef  DISABLE_ETHERNET

//BlinkLED(2000, 2);   //ok

 
  Set_enet_local0((uchar*)&enet_local0[0]);
//#ifndef PROG_PRM_PCH_N  
//    Initialize RTCS 
//#ifndef PROG_PRM_PCH_N   
//#ifndef  DISABLE_ETHERNET
 rtcs_result = RTCS_create();   //1a
//  Install RTCS Applications 


#ifndef USE_TCPIP_CLIENT
#ifndef USE_QUOTE_SERVER

#ifdef USE_TFTPSRV 
 rtcs_result = TFTPSRV_init("TFTP Server", 7L, 2000L);   //2a  //t 
#endif // USE_TFTPSRV
#ifdef USE_SNMP 
 rtcs_result = SNMP_init("SNMP Agent", 7L, 2000L); //3a
  MIB1213_init(); //4a //my
#endif //USE_SNMP  
  
  
#endif
#endif   

#ifdef HAVE_GATEWAY

 //RTCS_gate_add(GetNetwork(),(GetNetwork() & GetNetMask()), GetNetMask());   //for test
// RTCS_gate_add(GetNetwork(),GetNetwork(), GetNetMask());   //for test
RTCS_gate_add(GetNetwork(),0, 0);   //for test
 OldNetwork = GetNetwork();
 
  _IP_forward = TRUE;
  
#endif //HAVE_GATEWAY

  
//#ifndef PROG_PRM_PCH_N    
//#ifndef  DISABLE_ETHERNET

  rtcs_result = ENET_initialize(0, enet_local0, 0x00000000, &enet_handle0); //1b
  
  if (rtcs_result != ENET_OK) //?? olweis ok?
    {
      Enet_is_not_init();
    } 
//#endif    
    
//#endif  // PROG_PRM_PCH_N 
   rtcs_result = RTCS_if_add(enet_handle0, RTCS_IF_ENET, &ihandle0);  //2b
   
   
   
   
   
 //  rtcs_result = RTCS_if_bind(ihandle0, 0x9b9b9b0f, 0x00000000);
//     rtcs_result = RTCS_if_bind(ihandle0, 0x9b9b9b0e, 0x00000000);
//________________________________________
//keephandle = (unsigned long)(*ihandle0);

//________________________________________


//    rtcs_result = RTCS_if_bind(ihandle0, GetIP(), 0x00000000);   //3b
 //   rtcs_result = RTCS_if_bind(ihandle0, GetIP(), 0xFFFF0000);   //3b
 
//#ifdef HAVE_GATEWAY
//   rtcs_result = RTCS_if_bind(ihandle0, GetIP(), GetNetMask());   //3b
//  OldNetMask = GetNetMask();
 
//#else
//  rtcs_result = RTCS_if_bind(ihandle0, GetIP(), 0xFFFFFF00);   //3b
//#endif  
 //  OldIP = GetIP();    
   
//#ifdef HAVE_GATEWAY

// RTCS_gate_add(GetNetwork(),(GetNetwork() & GetNetMask()), GetNetMask());   //for test
// OldNetwork = GetNetwork();
//#endif //HAVE_GATEWAY
   
   
  // NAT_init();
   
 //  Add Gateways 
 //  rtcs_result = RTCS_gate_add(0x9b9b9b01, 0x00000000, 0x00000000);
//   if (rtcs_result != RTCS_OK)
 //     {
      //     while(1);
      //     State |= 0x40l;
 ///     } 
    //    aic_ptr->ICCR = 0xff;
       
    //      _int_enable();
    
    
//___________________________ok      
// BlinkLED(50, 4);  //ok
 // for(;;);
//___________________________ 
    
    
    
    
#ifdef TCPIP_CONNECT
#ifdef PROG_PRM_PCH_C

 start1 = 1;
// start1 = 0; //not need request at start
 start2 = 1;
 start3 = 1;
#endif // PROG_PRM_PCH_C

#ifdef PRM_PCH_N_RUN_IN_INTERRUPT 
 transfer_flag = 0;
#endif // PRM_PCH_N_RUN_IN_INTERRUPT 


#ifndef USE_TCPIP_CLIENT
#ifndef USE_QUOTE_SERVER
  buffer_rad_T_len = 0l;
  buffer_rad_T_lenU = 0l;

//100226 not need   rtcs_result = ECHOSRV_init   (taskname = "Echo server",   7, 1500);
//t  rtcs_result = RDNSRV_init   (taskname = "Radian server",   7, 1500);    //port 155
  rtcs_result = RDNSRV_init   (taskname = "Radian server",   7, BUFFER_SIZE_T); //100525 - 2000    //port 155/port 155s_result = RDNSRVT_init   (taskname = "Radian transmit",   7, 1500); //now setted my ip address 155.155.115.114
  rtcs_result = RDNSRVT_init   (taskname = "Radian transmit",   7, BUFFER_SIZE_T); //101125
#endif //USE_QUOTE_SERVER
#endif// USE_TCPIP_CLIENT



#endif //TCPIP_CONNECT  

#ifdef USE_HTTP

 _io_tfs_install("tfs:", tfs_data);

  
 root_dir[0].alias = "";
 root_dir[0].path  = "tfs:" ;
 root_dir[1].alias = 0;
 root_dir[1].path  = 0;
 
 
 //   { 0, 0 }
           
 /*   
root_dir[0,0] =   (struct httpd_root_dir_struct)"";
root_dir[0,1] = (struct httpd_root_dir_struct)"tfs:";
root_dir[1,0] = 0;
root_dir[1,1] = 0;
 */   
//};
 //ok   params = NULL;
  //    httpd_default_params(NULL);
   
   params = httpd_default_params(NULL);      //null do not work!!!
      
    if (params) {
        params->root_dir = (HTTPD_ROOT_DIR_STRUCT*)root_dir;
        params->index_page = "\\index.html";

//#if PSP_MQX_CPU_IS_MCF5223X
//        params->max_ses = 1;
//#endif
 //       server = httpd_init(params);
        
        }
          
        
#endif


//#endif //no PROG_PRM_PCH_N    
//#endif PROG_PRM_PCH_N     
 //_____________________________________
 usart_command_eth_off(); //need check this - or make bad work on act155N 
 
#endif  //DISABLE_ETHERNET


//___________________________ok      
// BlinkLED(1000, 1000); 
//  for(;;);
//___________________________ 


//  BlinkLED(100, 3);  //ok

#ifndef PROG_VNV1 
//#endif//  DISABLE_ETHERNET 
//_________________________________________________  
   if(!TestCheckSum())//not correct checksum
   {
   	SetBufferState((unsigned long)NO_CHECKSUM);
   }
   
   if(!Test_NVRAM())//not correctwrite-read
   {
   	SetBufferState((unsigned long)NO_NVRAM);
   }
//_______________________________________________ 
 
#endif
//___________________________ok      
 //BlinkLED(100, 3);  //ok
 // for(;;);
//___________________________ 
    
  

/*
#ifdef YOURNAL        //before init

  Add_Event(EV_POWER_ON, 0, NULL);
  
  
  Add_Event(EV_POWER_ON, 0, NULL);
  Add_Event(EV_POWER_ON, 0, NULL);
  Add_Event(EV_POWER_ON, 0, NULL);
  Add_Event(EV_POWER_ON, 0, NULL);
  Add_Event(EV_POWER_ON, 0, NULL);
  Add_Event(EV_POWER_ON, 0, NULL);
  Add_Event(EV_POWER_ON, 0, NULL);
  Add_Event(EV_POWER_ON, 0, NULL);
  Add_Event(EV_POWER_ON, 0, NULL);
  Add_Event(EV_POWER_ON, 0, NULL);
  Add_Event(EV_POWER_ON, 0, NULL);
  Add_Event(EV_POWER_ON, 0, NULL);
  Add_Event(EV_POWER_ON, 0, NULL);
  Add_Event(EV_POWER_ON, 0, NULL);
  Add_Event(EV_POWER_ON, 0, NULL);
  
  
  
  
  
#endif //YOURNAL 
 
  */
 
#ifdef PROG_MF20  

#ifndef PROG_BACO
  mf20_init(); ; //init remote buffers of MF20
#else
  baco_init();
#endif  
  
#endif //PROG_MF20 

#ifdef PROG_TUTS  
  TUTS_init();  //init remote buffers of TUTS
#endif //PROG_TUTS 

#ifdef PROG_BMD34
   Init_BMD34();
#endif //PROG_BMD34  

 

 #ifdef PROG_BUKC
  Init_BUKC();
  #endif //PROG_BUKC 
  
//BlinkLED(100, 3); 
  
  #ifdef PROG_PRM_PCH
//#ifndef	 PROG_PRM_PCH_SPI_ETH_UART  
  Init_PRM_PCH();   //hier is reset of ethernet
//#endif  
  
  
  #endif //PROG_PRM_PCH
  

// BlinkLED(1000, 3); 
  
   
  
  
  /*
  #ifdef PROG_PRM_PCH_DEM
  Init_PRM_PCH();
  #endif //PROG_PRM_PCH
  
 */ 
   /*
  #ifdef PROG_PU_M
  Init_PU_M();
  #endif //PROG_PU_M 
    */
  #ifdef PROG_PU_M_V
// if(GetTestMode() != 0x8el)
// {
//111

  Init_PU_M();
// }  
  #endif //PROG_PU_M 
  
    #ifdef PROG_PU_M_V_A
// if(GetTestMode() != 0x8el)
// {

//222
  Init_PU_M();
// }  
  #endif //PROG_PU_M 

  
   
  
  
  #ifdef PROG_PU_M100  
  
// 333 
    Init_PU_M();
  #endif //PROG_PU_M 

//  #ifdef PROG_PU_MSAT
//  Init_PU_M();
//  #endif //PROG_PU_MSAT 

  
   
  
   #ifdef PROG_PU_M_MUX
   
// 4444  
   
  Init_PU_M();
  #endif //PROG_PU_M_MUX  
  
  
  

  #ifdef PROG_BUKU
   Init_BUKC();
  #endif //PROG_BUKU  

  #ifdef PROG_PUM
  Init_BUKC();
  #endif //PROG_PUM  



 

#ifdef PROG_MPC155
#ifndef TEST_MPC155 
 if(CheckDoneShort()) 
  {
  Init_MPC155();
  }
#endif // TEST_MPC155 
#endif //PROG_MPC155 

#ifdef PROG_MPC4E
#ifndef TEST_MPC4E 
// if(CheckDoneShort()) 
//  {
  Init_MPC4E();
//  }
#endif // TEST_MPC4E 
#endif //PROG_MPC4E 




#ifdef PROG_BMD155
  Init_BMD155();
#endif //PROG_BMD155 

#ifdef PROG_COMMUTATOR
  Init_COMMUTATOR();
#endif //PROG_BMD155 


//#ifdef PROG_BMDN
//  Init_BMDN();
//#endif //PROG_BMDN 

//#ifdef PROG_UPS
// if(GetTestMode() != 0x8el)
// {
//  Init_UPS();
// }  
//  #endif //PROG_PU_M 


  
 
#ifdef PROG_MPC34
  Init_MPC34();
#endif //PROG_MPC34  

//___________________________ ok    
// BlinkLED(1000, 1000); 
 // for(;;);
//___________________________ 
// BlinkLED(200, 3);  //ok


 usart_select(0); //debug uart on  usart0 - off
//   m_uart_monitor(); //hier start menu
  m_usart1_init();  //
   usart_select (1); //debug uart off usart0 - on
   m_usart0_init(); //
   m_usart3_init();  
     m_usart2_init(); 
     
//#ifdef PROG_UPS
//#ifdef USE_USART2
// mode5AS = 0;
// Set_Usart2_To_RS485();
// time1old232S = 0l;
// embMsg485RequestS.Init();
//#endif // USE_USART2
//#endif  
     
//____________________________________
  _io_set_handle(IO_STDOUT, fusart0_ptr);  //t1109
  
  usart_select(1); //debug uart off usart0 - on
  
  
//BlinkLED(200, 3);  //ok
  
//___________________________ ok    
// BlinkLED(1000, 1000); 
 // for(;;);
//___________________________ 

  
  
#ifdef TEST_TRANSMIT_FROM_SSC1
 //  usart_select(0);
#endif  
//usart_select(0); //t100407
 // printf("\n\r start"); //100407
 //__________________________________
  //___________________________________________  Need after usart init     
  
// #ifdef PROG_PRM_PCH
//  Init_PRM_PCH();
//  #endif //PROG_PRM_PCH
//#ifdef PROG_UPS
//#ifdef USE_USART2
// mode5AS = 0;
// Set_Usart2_To_RS485();
// time1old232S = 0l;
// embMsg485RequestS.Init();
//#endif // USE_USART2
//#endif  
  
   
/* 110120  
#ifdef PROG_BMDN
  Init_BMDN();
#endif //PROG_BMDN 
 */ 
   //test 110318
 //  #ifdef PROG_PRM_PCH
 // Init_PRM_PCH();   //hier is reset of ethernet
 // #endif //PROG_PRM_PCH

  /*
  #ifdef PROG_PRM_PCH_DEM
  Init_PRM_PCH();
  #endif //PROG_PRM_PCH
 */ 

  
#ifdef PROG_UPS
//#ifndef 	PROG_PD1
 if(GetTestMode() != 0x8el)
 {
  Init_UPS();
 } 
//#endi 
#endif //PROG_PU_M 
   
  
  
#ifndef PROG_TUTS 
#ifdef USE_PULT 
#ifndef PROG_VNV1
 m_Test_PKU();
#endif 
#endif 
#endif
 // tChangeTestMode();
 //____________________________________________ 
#ifdef PROG_KTVM
   ktvm_init();  //init remote buffers of MF20
#endif //PROG_KTVM  mote buffers of TUTS

#ifdef PROG_DTVM
    dtvm_init();  //init remote buffers of MF20
#endif //PROG_KTVM  mote buffers of TUTS

//#ifdef PROG_BMD35
//   Init_BMD35();
//#endif //PROG_BMD35 

#ifdef PROG_PROV
   Init_PROV();
#endif //PROG_PROV 




#ifdef PROG_MPC35
   Init_MPC35();
#endif //PROG_MPC35 

#ifdef TEST_SLOW
SetLink10();
#endif // TEST_SLOW

//  #ifdef PROG_PU_M
//  Init_PU_M();
//  #endif //PROG_PU_M 


//printf("\n\r ETH_SER_OFF_TIMEOUT_ALL: %d", ETH_SER_OFF_TIMEOUT_ALL);     //200

 //_________________________________  
#ifndef NO_USE_WD 
  wd_init();    // 2e   // init watch dog 
#endif
  
//__________________________________________________

#ifdef USE_QUOTE_SERVER
   rtcs_result = QUOTE_SRV_init(taskname = "Quote server",   7, 1500);
#endif //USE_QUOTE_SERVER


//___________________________ ok    
// BlinkLED(200, 4); 
//  for(;;);
//___________________________ 



   
#ifdef PROG_ACT155N
   CheckClocks();
#endif // PROG_ACT155N

//______________________________________________
//for(cnt = 1; cnt <10000000;cnt  )
//{
//  cnt *= 10l;
//  delay_mcs1(cnt);
 
//}
   
  //  m_load_xilinx3((char)XILINXPG, 1); 
//___________________________________________________________________Sockets
#ifdef ETH_DEBUG_ENABLED
//printEthString("Start of programm!\n\r", 23);
//printf("Start of programm!\n\r");
#endif // ETH_DEBUG_ENABLED
//t  ktvm_init(); //for test
//printf("Start of programm!\n\r");

#ifdef LOAD_EXT_MODEM
//LoadExtModem();
#endif // LOAD_EXT_MODEM

#ifdef BMD155_ETH
	 InitXilBmdEth();
#endif // BMD155_ETH 

//____________________________________________________
#ifdef PROG_DTVM
/*
outportb(0xf8, 0x03);
//delay_mcs(10000l);
outportb(0xf9, 0x03);
delay_mcs(10000l);
delay_mcs(10000l);
delay_mcs(10000l);
delay_mcs(10000l)00l)elay_mcs(10000l);
delay_mcs(10000l);
delay_mcs(10000l);
delay_mcs(10000l);
delay_mcs(10000l);
delay_mcs(10000l);
delay_mcs(10000l);
delay_mcs(10000l);
delay_mcs(10000l);
delay_mcs(10000l);
delay_mcs(10000l);
delay_mcs(10000l);
delay_mcs(10000l);
delay_mcs(10000l);
delay_mcs(10000l);
delay_mcs(10000l);

outportb(0xf8, 0x03);

delay_mcs(100000l);
delay_mcs(100000l);
delay_mcs(100000l);
delay_mcs(100000l);
delay_mcs(100000l);
delay_mcs(100000l);
delay_mcs(100000l);
delay_mcs(100000l);
delay_mcs(100000l);
delay_mcs(100000l);

*/

  
delay_mcs(100000l);
delay_mcs(100000l);
delay_mcs(100000l);
delay_mcs(100000l);
delay_mcs(100000l);
delay_mcs(100000l);
delay_mcs(100000l);
delay_mcs(100000l);
delay_mcs(100000l);
delay_mcs(100000l);

//outportb(0xf8,0x03);
//outportb(0xf9,0x03);

SetE14();
  
#endif //PROG_DTVM
#ifdef PROG_MPC4E
//printf("\n\r start main loop");

#endif //PROG_MPC4E


//_______________________________________________
//printf("...Enable Interrupts\n\r");
//#ifndef PROG_TUTS
//#ifndef WITHOUT_INTERRUPTS
//  EnableInterrupts();
//#endif //WITHOUT_INTERRUPTS  
//#endif //no PROG_TUTS 


//#ifndef PROG_PRM_PCH_N

#ifndef  DISABLE_ETHERNET 
  usart_command_eth_on();
#else
//151019  usart_command_eth_off();
#endif//  DISABLE_ETHERNET

//#endif //PROG_PRM_PCH_N


  //socket();
 //____________________________________________________________Sockets

#ifdef USART0_TRY_PDC
   enableRxPdcUsart0();
#endif //USART0_TRY_PDC

#ifdef USART1_TRY_PDC
   enableRxPdcUsart1();
#endif //USART1_TRY_PDC

#ifdef USART2_TRY_PDC
   enableRxPdcUsart2();
#endif //USART2_TRY_PDC


#ifdef USART0_TRY_PDC_1
 
   enableRxPdcUsart0();
   
#endif //USART0_TRY_PDC_1

#ifdef USART0_TRY_PDC_1T
 
   enableTxPdcUsart0();
   
#endif //USART0_TRY_PDC_1T

#ifdef USART1_TRY_PDC_1T
 
   enableTxPdcUsart1();
   
#endif //USART1_TRY_PDC_1T

#ifdef USART2_TRY_PDC_1T
 
   enableTxPdcUsart2(); //added 101004
   
#endif //USART1_TRY_PDC_1T


//___________________________ ok    
// BlinkLED(500, 500); 
//  for(;;);
//___________________________ 

//BlinkLED(200, 3);  

#ifdef YOURNAL        //not before init to have only one event to do not rewrite previons

  Add_Event(EV_POWER_ON, 0, NULL);
#endif



//___________________________ ok    
// BlinkLED(100,3); 
//  for(;;);
//___________________________ 





 #ifdef PROG_PU_MSAT
   printfp("\n\r go Init_PU_M();");

  Init_PU_M();
  #endif //PROG_PU_MSAT 
//printfp("\n\r go Init_PRM_PCH();");
//OperateBuffers_usart0t();


// BlinkLED(200, 5); 
 
//  #ifdef PROG_DMU6
//  Init_PRM_PCH();
//  #endif //PROG_PRM_PCH

 
  #ifdef PROG_PRM_PCH_DEM
   printfp("\n\r go Init_PRM_PCH();");
   OperateBuffers_usart0t();
     Init_PRM_PCH();
  #endif //PROG_PRM_PCH
  
//  BlinkLED(400, 4);
  
  #ifdef	 PROG_PRM_PCH_SPI_ETH_UART  
   printfp("\n\r go Init_PRM_PCH();");

  Init_PRM_PCH();   //hier is reset of ethernet
#endif  

 
  
//___________________________wrong      
// BlinkLED(1000, 1000); 
//  for(;;);
//___________________________     
  
// BlinkLED(60, 5); 
   

#ifdef PROG_BMDN
  printfp("\n\r go Init_BMDN();");
OperateBuffers_usart0t();


  Init_BMDN();
  
  printfp("\n\r Finish Init_BMDN();");
OperateBuffers_usart0t();
 
  
  
#endif //PROG_BMDN 





//   BlinkLED(10, 5);


// printfp("\n\r finish Init_BMDN();");
//OperateBuffers_usart0t();


//  BlinkLED(80, 5);
//___________________________ ok    
// BlinkLED(50, 500); 
 // for(;;);
//___________________________ 


#ifdef PROG_BMD35
   Init_BMD35();
#endif //PROG_BMD35 

#ifdef PROG_PU_M
  Init_PU_M();
#endif //PROG_PU_M 

//#ifdef PROG_PU_M_MUX
//  Init_PU_M();
//#endif //PROG_PU_M 


//bad   outportb(0x506, 0x55); //t

//#ifdef XIL_FLASH    //hier for test
//  AT91F_DataflashInitx ();
//  FillXilFileDatax(MODEM_QUANTITY);
//#endif 

 /*140819

#ifndef PROG_TUTS
#ifndef WITHOUT_INTERRUPTS
  EnableInterrupts();
#endif //WITHOUT_INTERRUPTS  
#endif //// PROG_TUTS 

//okoutportb(0x506, 0x55); //t
140819 */

//InitFinish = 1; //end of init

// testWrite(); //t090807
//#ifdef YOURNAL
//  Add_Event(EV_POWER_ON, 0, NULL);
//#endif //YOURNAL 

//#ifndef PROG_BMDN1
#ifdef PROG_BMDN
#ifndef MANY_MODEMS

//t111109    StartModem();
    
#else
//101028    StartModems(MODEM_QUANTITY);
#endif //MANY_MODEMS   

#ifdef TRY_UNBLOCK
#ifndef USART0_TRY_PDC_1T
printf("\n\r... start read id");
#endif
// temporary 
//tcpip_id = _task_get_id_from_name(name_ptr);

tcpip_id = _task_get_id_from_name("TCP/IP");
snmp_id = _task_get_id_from_name("SNMP Agent");
rdn_id = _task_get_id_from_name("Radian server");
rdnt_id = _task_get_id_from_name("Radian transmit");
tftp_id = _task_get_id_from_name("TFTP Server");

#ifndef USART0_TRY_PDC_1T
printf("\n\r tcp_id = %d", tcpip_id);  //it is 10003(hex)
printf("\n\r snmp = %d", snmp_id);  //it is 10003(hex)
printf("\n\r rdn_id = %d", rdn_id);  //it is 10003(hex)
printf("\n\r tftp_id = %d", tftp_id);  //it is 10003(hex)
//   
printf("\n\r...end read id");
#endif
#endif

 
    
#endif //PROG_BMDN
//#endif //PROG_BMDN1


 
//#ifdef TEST_HELLO_PRINT
//printf("\n\r start main loop");
//#endif  

if(GetTestMode() == 0xAA)
  {
   SetTestMode(1l);
    WriteDevId();    //140819

  } 
  
if(GetTestMode() == 0x22)
  {
   SetTestMode(1l);
    WriteDevId();    //140819

  } 
  


if(GetTestMode() == 0x8el)   //restart only rtcs
  {
  SetTestMode(1l);
//130917  WriteDevId();
   WriteDevId();    //140819
  } 
  
if(GetTestMode() == 0x7l)   //restart only rtcs
  {
  SetTestMode(1l);
//130917  WriteDevId();
   WriteDevId();    //140819
  } 

  
  
//#ifdef TEST_REMOTE_FF  
// printfpd("\n\r%X", check[0]);
// printfpd("\n\r%X", check[1]);
// printfpd("\n\r%X", check[2]);
// printfpd("\n\r%X", check[3]);
// printfpd("\n\r%X", check[4]);
//OperateBuffers_usart0t(); 
//#endif
start_main_loop  = 1;
//#ifdef	PROG_PRM_PCH_DEM_XIL_CHN_DMU3
//LoadBand();
//#endif

#ifndef DISABLE_ETHERNET


#ifdef USE_HTTP      
 // if(server != NULL)
 // printfp("HTTP SERVER START");
          server = httpd_init(params);
          
  HTTPD_SET_PARAM_CGI_TBL(server, (HTTPD_CGI_LINK_STRUCT*)cgi_lnk_tbl); //120410
          
         httpd_server_run(server); //120405   try task mode
  #endif  

 //TestWriteFlash5();  
 
#ifdef HAVE_GATEWAY
   rtcs_result = RTCS_if_bind(ihandle0, GetIP(), GetNetMask());   //3b
  OldNetMask = GetNetMask();
 
#else
  rtcs_result = RTCS_if_bind(ihandle0, GetIP(), 0xFFFFFF00);   //3b
#endif  
  OldIP = GetIP(); 
#ifdef USE_SOCKETS
// Set up the UDP port (Quote server services port 17): 
laddr.sin_family = AF_INET;
//090216 laddr.sin_port = 17;
laddr.sin_port = TCP_PORT;
laddr.sin_addr.s_addr = INADDR_ANY;
// Create a datagram socket: 
//sock = socket(PF_INET, SOCK_DGRAM, 0);
//if (sock == RTCS_SOCKET_ERROR) {
//printf("\nFailed to create datagram socket.");
//_task_block();
//}
// Bind the datagram socket to the UDP port: 
//error = bind(sock, &laddr, sizeof(laddr));
//if (error != RTCS_OK) {
//printf("\nFailed to bind datagram - 0x%lx.", error);
//_task_block();
//}
// Create a stream socket: 
sock = socket(PF_INET, SOCK_STREAM, 0);
if (sock == RTCS_SOCKET_ERROR) {
//printf("\nFailed to create the stream socket.");
_task_block();
}
// Bind the stream socket to a TCP port: 
error = bind(sock, &laddr, sizeof(laddr));
if (error != RTCS_OK) {
//printf("\nFailed to bind the stream socket - 0x%lx", error);
_task_block();
}
// Set up the stream socket to listen on the TCP port: 
error = listen(sock, 0);
if (error != RTCS_OK) {
//printf("\nlisten() failed - 0x%lx", error);
_task_block();
}
listensock = sock;
//printf("\n\nQuote Server is active on port  on port 
//index = 0;
#endif // USE_SOCKETS


#ifdef USE_SOCKETSD
// Set up the UDP port (Quote server services port 17): 
//laddrd.sin_family = AF_INET;
//090216 laddr.sin_port = 17;
//laddrd.sin_port = TCP_PORT;
//laddrd.sin_addr.s_addr = INADDR_ANY;

   /*t
   laddrd.sin_family      = AF_INET;
   laddrd.sin_port        = IPPORT_RADIANT;
   laddrd.sin_addr.s_addr = INADDR_ANY;
    */

// Create a datagram socket: 
//sock = socket(PF_INET, SOCK_DGRAM, 0);
//if (sock == RTCS_SOCKET_ERROR) {
//printf("\nFailed to create datagram socket.");
//_task_block();
//}
// Bind the datagram socket to the UDP port: 
//error = bind(sock, &laddr, sizeof(laddr));
//if (error != RTCS_OK) {
//printf("\nFailed to bind datagram - 0x%lx.", error);
//_task_block();
//}

  /* Bind to UDP port */
 //  sockd = socket(PF_INET, SOCK_DGRAM, 0);
  // if (sockd == RTCS_SOCKET_ERROR) {
  //    RTCS_task_exit(creator, RTCSERR_OUT_OF_SOCKETS);
  // } /* Endif */
//   errord = bind(sockd, &laddrd, sizeof(laddrd));
 //  if (errord) {
  //    RTCS_task_exit(creator, error);
 //  } /* Endif */

 /*

// Create a stream socket: 
sockd = socket(PF_INET, SOCK_STREAM, 0);
if (sockd == RTCS_SOCKET_ERROR) {
//printf("\nFailed to create the stream socket.");
_task_block();
}



// Bind the stream socket to a TCP port: 
errord = bind(sockd, &laddrd, sizeof(laddrd));
if (errord != RTCS_OK) {
//printf("\nFailed to bind the stream socket - 0x%lx", error);
_task_block();
}


  

// Set up the stream socket to listen on the TCP port: 
errord = listen(sockd, 0);
if (errord != RTCS_OK) {
//printf("\nlisten() failed - 0x%lx", error);
_task_block();
}
*/
//listensockd = sockd;

//printf("\n\nQuote Server is active on port  on port 
//index = 0;

//__________________________
 flag_send_udp_asu = 0;
   len_udpt = 0;
   New_TTL = TRANSIT_TTL;

 
//memset((char *) &raddrd, 0, sizeof(raddrd));
//raddrd.sin_family = AF_INET;
//raddrd.sin_addr.s_addr = 0xFFFFFFFFl;
//raddrd.sin_addr.s_addr = 0;
//raddrd.sin_port = 2010;
 

memset((char *) &local_sin, 0, sizeof(local_sin));
local_sin.sin_family = AF_INET;
//tlocal_sin.sin_addr.s_addr = 0xFFFFFFFFl;
local_sin.sin_addr.s_addr = 0;
local_sin.sin_port = 2010;

socklist[0] = socket(AF_INET, SOCK_DGRAM, 0);
result = bind(socklist[0], &local_sin, sizeof (sockaddr_in));
//result = listen(socklist[0], 0);

 



 /*
local_sin.sin_port = 2011;
socklist[1] = socket(AF_INET, SOCK_DGRAM, 0);
result = bind(socklist[1], &local_sin, sizeof (sockaddr_in));
  */
/*
local_sin.sin_port = 2012;
socklist[2] = socket(AF_INET, SOCK_DGRAM, 0);
result = bind(socklist[2], &local_sin, sizeof (sockaddr_in));
 */



#endif // USE_SOCKETS

#ifdef USE_SOCKETSD_485
 flag_send_udp_asu_485 = 0;
   len_udpt_485 = 0;
   New_TTL_485 = TRANSIT_TTL;
memset((char *) &local_sin_485, 0, sizeof(local_sin_485));
local_sin_485.sin_family = AF_INET;
local_sin_485.sin_addr.s_addr = 0;
local_sin_485.sin_port = 2011;  //use for 485 2011 port
socklist_485[0] = socket(AF_INET, SOCK_DGRAM, 0);
result_485 = bind(socklist_485[0], &local_sin_485, sizeof (sockaddr_in));
 /*
local_sin.sin_port = 2011;
socklist[1] = socket(AF_INET, SOCK_DGRAM, 0);
result = bind(socklist[1], &local_sin, sizeof (sockaddr_in));
  */
/*
local_sin.sin_port = 2012;
socklist[2] = socket(AF_INET, SOCK_DGRAM, 0);
result = bind(socklist[2], &local_sin, sizeof (sockaddr_in));
 */
#endif // USE_SOCKETS










#endif   //disable_ethernet

 #endif TEST_MAKET
 
 
 //___________________________ ok    
// BlinkLED(30, 1500); 
 // for(;;);
//___________________________ 


//printfp("Start main");
// OperateBuffers_usart0t(); 

//#ifndef FIND_KSS_ERR
 
#ifdef PROG_COMMUTATOR1
#ifdef USE_USART2
#ifndef MAKET_PLATA	
 Set_Usart2_To_RS485();  //pa31:dtxd  = rts2 if usart2 -= rs485 ihis pin is low!!!!
#endif 
 SetUsart2BaudRate(38400l);
#endif
#endif

//_____________________________________________140819
#ifndef PROG_TUTS
#ifndef WITHOUT_INTERRUPTS
  EnableInterrupts();
#endif //WITHOUT_INTERRUPTS  
#endif //no PROG_TUTS 
//_____________________________________________140819


 //___________________________ ok    
// BlinkLED(30, 25); 
 // for(;;);
//___________________________ 



 /*
#ifdef YOURNAL        //before init

  Add_Event(EV_POWER_ON, 0, NULL);
  
  Add_Event(EV_COMMAND_CONFIG, 0, NULL);
  Add_Event(EV_COMMAND_CONFIG, 0, NULL);
  Add_Event(EV_COMMAND_CONFIG, 0, NULL);
  Add_Event(EV_COMMAND_CONFIG, 0, NULL);
  Add_Event(EV_COMMAND_CONFIG, 0, NULL);
  Add_Event(EV_COMMAND_CONFIG, 0, NULL);
  Add_Event(EV_COMMAND_CONFIG, 0, NULL);
  Add_Event(EV_COMMAND_CONFIG, 0, NULL);
  Add_Event(EV_COMMAND_CONFIG, 0, NULL);
  Add_Event(EV_COMMAND_CONFIG, 0, NULL);
  Add_Event(EV_COMMAND_CONFIG, 0, NULL);
  Add_Event(EV_COMMAND_CONFIG, 0, NULL);
   
  
  
  
  
#endif //YOURNAL 

*/
//#endif

//t cashe_on();
 //ok  outportb(0x506, 0x55); //ok
 
#ifdef PROG_BMDN
  printfp("\n\r go  step1 BMDN();");
  OperateBuffers_usart0t();
#endif //PROG_BMDN 



//BlinkLED(100, 5); 

 
 
#ifndef PROG_VNV
 
#ifdef XIL_FLASH

#ifndef PROG_MD310_SATI 
  AT91F_DataflashInitx(); 
  
//#ifndef PROG_MD310_SATI 
  FillXilFileDatax(0);
#endif  
#ifdef PROG_MD310_SATI 
 // AT91F_DataflashInitx(); 
  
//#ifndef PROG_MD310_SATI 
//  FillXilFileDatax(0);
#endif  

#ifdef PROG_ODU1 
 // AT91F_DataflashInitx(); 
  
//#ifndef PROG_MD310_SATI 
  FillXilFileDatax(0);
#endif  



#endif 
#endif //PROG_VNV 
 
//BlinkLED(300, 2); 
 
 
#ifdef START_PRINT 
 //  printfp("\n\rStart main \n\r");
 //   printfp2("Start main2\n\r");

 //  printfpd( "%02X\n\r", inportb(0x506));
//BlinkLED(1000, 1000);  
#endif
 
 
#endif // TESTSTART 

//t150901 AT91F_DataflashPrintInfo ();
#ifdef PROG_BMDN
  printfp("\n\r go  step2 BMDN();");
  OperateBuffers_usart0t();
#endif //PROG_BMDN 
 BlinkLED(100, 1); 
 
   while (TRUE) 
      {
//#ifdef PROG_MD310
//  my_int_enable_irq0();    
//#endif      
      
      
//#ifdef USE_HTTP    
//printfp(",");  
//120405  httpd_server_poll(server, 1);
//#endif  
      
      
   //  return; 
//_time_delay_ticks((_mqx_uint)1); //t101201      
// pio_ptr1->CODR = tg; //t      
//Enable_irqs_for_task();
      
      
//#ifdef PROG_BMDN
   // if(!fl_start_modem)
  //  {
   //   fl_start_modem = 1;
   //    StartModem();
       
  //  }
//#endif //PROG_BMDN

      
      
      
      
// my_int_disable_eth(); //t0624
// my_int_enable_eth(); //test 090624      
      
   //  ENET_lock(); 
      
    //  _int_enable();
   //     pio_ptr1->SODR = tg;
      
   //   my_int_enable_usart0();
//___________________________________________________________________Sockets


#ifdef USE_SOCKETS     //it is not defined!!!!!
//for (;;) {
//sock = RTCS_selectall(0); //t090216
// sock = RTCS_selectall(1);   //t
//soso = RTCS_selectset(socklist, 3, 0);
//sock = RTCS_selectall(-1); //t090216
 //sock = RTCS_selectall(0); //t090216

sock = RTCS_selectset(&listensock, 1, -1);
if (sock == listensock) 
//if(1)    //t 090216
{
// Connection requested; accept it. 
   rlen = sizeof(raddr);
   // printf("\n rlen : 0x%lx", rlen);
   sock = accept(listensock, &raddr, &rlen);
   if (sock == RTCS_SOCKET_ERROR) 
    //  if( (sock == RTCS_SOCKET_ERROR) || (sock != RTCS_OK)) //0216
         {
//100202            printf("\n accept() failed, error 0x%lx", RTCS_geterror(listensock));
        //    continue;
         }
 //    printf("\n\r Connecting to client: 0x%08x\n", raddr.sin_addr.s_addr);

     
//________________________________________________________________server sending comment         
// Send back a quote: 
//t send(sock, Quotes[index], strlen(Quotes[index]) + 1, 0);
 //t 090216 server sending comment  send(sock, &SockBuff[0], SIZE_SOCK_BUFF, 0);
//________________________________________________________________server sending comment            
   
//__________________________________________________ from client - receive data
  
 //t        _time_delay(1000);
           //     numbytes = recv(socket_stream, buff, sizeof(buff), 0);
  else //090216
   {
   
    
   
   
  //   _time_delay(1000);
 //  _time_delay(1000);

       //   printf("sock: 0x%lx\n", sock);

       //  numbytes = recv(sock, buff, sizeof(buff), 0);
         numbytes = recv(sock, buff, 500, 0);
     //    if (numbytes == RTCS_ERROR) {
         if (numbytes <= 0) {
       //     printf("recv error: 0x%lx\n", RTCS_geterror(socket_stream));
//100202            printf("recv error: 0x%lx\n", RTCS_geterror(sock));
   //    printf("numbytes: 0x%lx\n", numbytes);
     //t        shutdown(sock, FLAG_CLOSE_TX); //t 090216_1
     //       continue;
         } 
         else //my
         {
      //   printf("\n\r Connecting to c cent: 0x%08x\n", raddr.sin_addr.s_addr);
           send(sock, buff, numbytes, 0);    //t 090216_1
      //  }
            t_count++;
       //  buff[numbytes] = '\0';
      //   printf("%s\n>>", buff);
//100201        printf("\n\r>%d",t_count);
          }
     }
//__________________________________________________ from client - receive data   
   
   
 //t 090216 _time_delay(1000);
  // shutdown(sock, FLAG_CLOSE_TX);
 // ++index; //t
} 

// else  //datagramm
//{

// Datagram socket receive strlen(Quotes[index]) + 1, 0);
// send(sock, &SockBuff[0], SIZE_SOCK_BUFF, 0);
//  _time_delay(1000);
//shutdown(sock, FLAG_CLOSE_TX);
// ++index; //t
// }  //no listensock
  
//0213else      //datagrammm
//0213{
// Datagram socket receiveving from %d.%d.%d.%d,%d",RTCS_geterror(sock),(raddr.sin_addr.s_addr >> 24) & 0xFF,(raddr.sin_addr.s_addr >> 16) & 0xFF,(raddr.sin_addr.s_addr >> 8) & 0xFF,raddr.sin_addr.s_addr & 0xFF,raddr.sin_port);
 //0213    continue;
 //0213    }
// Send back a quote: 
//t sendto(sock, Quotes[index], strlen(Quotes[index]) + 1, 0, &raddr, rlen);
 // sendto(sock,&SockBuff[0], SIZE_SOCK_BUFF, 0, &raddr, rlen);

//  ++index; //t
 //????   was * with slash
//}
//t ++index;
//t if (Quotes[index] == NULL) {  index = 0;  }
//}
#endif // USE_SOCKETS


#ifdef USE_SOCKETSD     //it is not defined!!!!!
//for (;;) {
//sock = RTCS_selectall(0); //t090216
// sock = RTCS_selectall(1);   //t
//soso = RTCS_selectset(socklist, 3, 0);
//sock = RTCS_selectall(-1); //t090216
 //sock = RTCS_selectall(0); //t090216

//sockd = RTCS_selectset(&listensockd, 1, -1);
//if (sockd == listensockd) 
//if(1)    //t 090216
//{
// Connection requested; accept it. 
  // rlend = sizeof(raddrd);
   // printf("\n rlen : 0x%lx", rlen);
  // sockd = accept(listensockd, &raddrd, &rlend);
 //  if (sockd == RTCS_SOCKET_ERROR) 
    //  if( (sock == RTCS_SOCKET_ERROR) || (sock != RTCS_OK)) //0216
       //  {
//100202            printf("\n accept() failed, error 0x%lx", RTCS_geterror(listensock));
        //    continue;
      //   }
 //    printf("\n\r Connecting to client: 0x%08x\n", raddr.sin_addr.s_addr);

     
//________________________________________________________________server sending comment         
// Send back a quote: 
//t send(sock, Quotes[index], strlen(Quotes[index]) + 1, 0);
 //t 090216 server sending comment  send(sock, &SockBuff[0], SIZE_SOCK_BUFF, 0);
//________________________________________________________________server sending comment            
   
//__________________________________________________ from client - receive data
  
 //t        _time_delay(1000);
           //     numbytes = recv(socket_stream, buff, sizeof(buff), 0);
 // else //090216
  // {
   
    
   
   
  //   _time_delay(1000);
 //  _time_delay(1000);

       //   printf("sock: 0x%lx\n", sock);

       //  numbytes = recv(sock, buff, sizeof(buff), 0);
      //   numbytes = recv(sockd, buff, 500, 0);
     //    if (numbytes == RTCS_ERROR) {
      //   if (numbytes <= 0) {
       //     printf("recv error: 0x%lx\n", RTCS_geterror(socket_stream));
//100202            printf("recv error: 0x%lx\n", RTCS_geterror(sock));
   //    printf("numbytes: 0x%lx\n", numbytes);
     //t        shutdown(sock, FLAG_CLOSE_TX); //t 090216_1
     //       continue;
      //   } 
        // else //my
        // {
      //   printf("\n\r Connecting to c cent: 0x%08x\n", raddr.sin_addr.s_addr);
      //     send(sockd, buff, numbytes, 0);    //t 090216_1
      //  }
      //      t_count++;
       //  buff[numbytes] = '\0';
      //   printf("%s\n>>", buff);
//100201        printf("\n\r>%d",t_count);
      //    }
    // }
//__________________________________________________ from client - receive data   
   
   
 //t 090216 _time_delay(1000);
  // shutdown(sock, FLAG_CLOSE_TX);
 // ++index; //t
//} 

// else  //datagramm
//{

// Datagram socket receive strlen(Quotes[index]) + 1, 0);
// send(sock, &SockBuff[0], SIZE_SOCK_BUFF, 0);
//  _time_delay(1000);
//shutdown(sock, FLAG_CLOSE_TX);
// ++index; //t
// }  //no listensock
  
//0213else      //datagrammm
//0213{
// Datagram socket receiveving from %d.%d.%d.%d,%d",RTCS_geterror(sock),(raddr.sin_addr.s_addr >> 24) & 0xFF,(raddr.sin_addr.s_addr >> 16) & 0xFF,(raddr.sin_addr.s_addr >> 8) & 0xFF,raddr.sin_addr.s_addr & 0xFF,raddr.sin_port);
 //0213    continue;
 //0213    }
// Send back a quote: 
//t sendto(sock, Quotes[index], strlen(Quotes[index]) + 1, 0, &raddr, rlen);
 // sendto(sock,&SockBuff[0], SIZE_SOCK_BUFF, 0, &raddr, rlen);

//  ++index; //t
 //????   was * with slash
//}
//t ++index;
//t if (Quotes[index] == NULL) {  index = 0;  }
//}


//while (TRUE) {
//sock = RTCS_selectset(socklist, 3, 0);
  
sockd = RTCS_selectset(socklist, 1, -1);

if (sockd == socklist[0]) 
//if(1)    //t 090216
{
// memset(&raddrd, 0, sizeof(raddrd));
rlend = sizeof(raddrd);
//lengthd = recvfrom(sockd, buffer, BUFFER_SIZE, 0, &raddrd, &rlend);
lengthd = recvfrom(sockd, buff, BUFF_SIZE_DATAG, 0, &raddrd, &rlend);

#ifndef UDP_DEBUG

 FillEthTransit((unsigned char*)(&buff[0]), (unsigned long) lengthd);
 
#endif 


//printfpd("\n\r%d>Is received :", time1);
//buff[20] = 0; //for debug 
//printfp(buff);

//sendto(sockd, buffer, lengthd, 0, &raddr, rlend);
//sendto(sockd, buff, lengthd, 0, &raddrd, rlend);
// sendto(sock,  buffer_rad_TU, buffer_rad_T_lenU, 0, &raddr, rlen);
}

if(flag_send_udp_asu)
{
 flag_send_udp_asu = 0;
 sockd = socklist[0]; 
// sockd = socklist[1];  //enover port
 printfpd("\n\rTry send UDP.len :.%d", len_udpt); 
  if(len_udpt > BUFF_SIZE_DATAG) 
{ 
len_udpt = BUFF_SIZE_DATAG;
//   printfp("\n\rwrong Len!!!!");
}
 OperateBuffers_usart0t();

//len_udpt = BUFF_SIZE_DATAG; //for test
//oklen_udpt = 1480;
//len_udpt = 2000;
//len_udpt = 9600;


 
memset((char *) &raddrd, 0, sizeof(raddrd));
raddrd.sin_family = AF_INET;

//160826 raddrd.sin_addr.s_addr = 0xFFFFFFFFl;
#ifndef UDP_DEBUG

raddrd.sin_addr.s_addr = GetIPRemUDP();

#else
raddrd.sin_addr.s_addr = 0x9B9B9BE6;    //ip remote 230 : ok
//raddrd.sin_addr.s_addr = 0x9B9B9B4E;    //ip remote 78 : ok
//raddrd.sin_addr.s_addr = 0x9B9B9B02;    //ip 02

#endif

//printfpd("\n\rGetIPRemUDP()> 0x%08X",GetIPRemUDP());



raddrd.sin_port = 2010;
 
// uint_32 MIB_set_ipDefaultTTL (pointer dummy, uchar_ptr varptr, uint_32 varlen)
 // MIB_set_ipDefaultTTL (0, uchar_ptr varptr, uint_32 varlen)

// sendto(sockd, "ASU Data", sizeof("ASU Data"), 0, &local_sin, sizeof(sockaddr_in));

//t sendto(sockd, buff_udpt , len_udpt, RTCS_MSG_NOLOOP, &local_sin, sizeof(sockaddr_in));
if((raddrd.sin_addr.s_addr & 0xFFFFFF00) !=  0xFFFFFF00)
{ 
  pTTL = Set_ipDefaultTTL (&New_TTL);
  Old_TTL = *pTTL;
 sendto(sockd, buff_udpt , len_udpt, RTCS_MSG_NOLOOP, &raddrd, sizeof(raddrd));
Set_ipDefaultTTL (&Old_TTL);
}

 
//delay_mcs(200); 
 
 
len_udpt = 0; 
 
  
}




#endif // USE_SOCKETSD

#ifdef USE_SOCKETSD_485     //it is not defined!!!!!
sockd_485 = RTCS_selectset(socklist_485, 1, -1);
if (sockd_485 == socklist_485[0]) 
{
rlend_485 = sizeof(raddrd_485);
lengthd_485 = recvfrom(sockd_485, buff_485, BUFF_SIZE_DATAG, 0, &raddrd_485, &rlend_485);
 FillEthTransit_485((unsigned char*)(&buff_485[0]), (unsigned long) lengthd_485);


//printfpd("\n\r%d>Is received :", time1);
//buff[20] = 0; //for debug 
//printfp(buff);
}

if(flag_send_udp_asu_485)
{
 flag_send_udp_asu_485 = 0;
 sockd_485 = socklist_485[0]; 
// printfpd("\n\rTry send UDP.len :.%d", len_udpt); 
  if(len_udpt_485 > BUFF_SIZE_DATAG) 
{ 
len_udpt_485 = BUFF_SIZE_DATAG;
//   printfp("\n\rwrong Len!!!!");
}
// OperateBuffers_usart0t();
 
memset((char *) &raddrd_485, 0, sizeof(raddrd_485));
raddrd_485.sin_family = AF_INET;
raddrd_485.sin_addr.s_addr = 0xFFFFFFFFl;
raddrd_485.sin_port = 2011; //port for 485E
 
pTTL_485 = Set_ipDefaultTTL (&New_TTL_485);
  Old_TTL_485 = *pTTL_485;
 sendto(sockd_485, buff_udpt_485 , len_udpt_485, RTCS_MSG_NOLOOP, &raddrd_485, sizeof(raddrd_485));
Set_ipDefaultTTL (&Old_TTL_485);
 
 
len_udpt_485 = 0; 
  
}




#endif // USE_SOCKETSD












//___________________________________________________________Sockets     
  // my_int_disable();      //t
#ifndef WITHOUT_DEVICE
 //#ifndef PRf PRTVM //temporary
  Devise();   //1e
 //#endif //PROG_DTVM 
#else 
   wd_reset();
#endif //  

//testprint();
#ifdef USE_TCPIP_CLIENT
if (q_client_counter < PAKETS_LIMIT)
{
   QUOTE_client(0l);
    q_client_counter++;
}
#endif //USE_TCPIP_CLIENT  


 //  my_int_enable();      //t
    //   aic_ptr->EOICR = 0xFF; //090326 to com from spurious interrupt if it go, this need add to idle task
 // if((TimerCounter - Stephany6) > (uint_32)0x000001FFl)
  pinger++;
 //  printEthLongHex(pinger);
/* 
#ifdef	 PROG_PRM_PCH_SPI_XIL
   if(led)
   {
   pio_ptr1->CODR = tg; //(1<<pin);
   led = 0;
  // TUTS_Output_Set(0);
  //  send485_enabled = 0;
  //  printfp("1");

   }
  else
   {
   led = 1;
   pio_ptr1->SODR = tg; //(1<<pin);
 //   send485_enabled = 1;

 //   TUTS_Output_Set(0xff);
//   printfp("0");
   }
#endif     
*/ 
 
#ifdef PROG_PRM_PCH_N 
#ifdef TEST_PRM_PCH_1
    if((pinger - Stephany6) > 5000)
#else
  if((pinger - Stephany6) > 500)
#endif  
#else   // PROG_PRM_PCH_N 
   if((pinger - Stephany6) > 500)
#endif //PROG_PRM_PCH_N    
  
  //  if(1)   //t09
  {
//________________________t 
#ifdef CHECK_LOSS_MEM 
  checklossmem();
#endif  
//________________________t
  //  printfpd("\n\r>%d <\n\r", InterruptWatchDog);

 // printfpd("<_ %d",_task_get_status_from_name ("TCP/IP"));   //261 -> 11
//   printfpd(" %d_>",task_get_error_from_name ("TCP/IP"));

  
#ifdef YOURNAL
 //t  Add_Event(EV_POWER_OFF, 0, NULL); //power off
   Add_Event(EV_POWER_OFF, 4, "1234"); //power off
  // printfp("\n\r...");
#endif //
  
//#ifdef TEST_PUMV_ERR  
// SetTestMode(0x97);
// ChangeTestMode(); 
//#endif  

//ok RTCS_ping(0x0a000005, 0, 1);
//ok RTCS_ping(0x9b9b9b76, 0, 1); //ok
  
  
#ifdef PROG_PRM_PCH_N_1
if(!use_standard_protocol)
{
//tSetLed2(0);
SetLed2(1);   //t
SetLed3(1);
}
#endif // PROG_PRM_PCH_1
  
  //  print_signature();
  
  
#ifdef PROG_BMDN  
//if(GetTestMode() != 0x7 )
//{
// GetVersionAPI(); //for test   
//}
// GetVersionAPI(); //for test  
 
#endif //PROG_BMDN 
  
//#ifdef USE_TCPIP_CLIENT
//if (q_client_counter < 1000)
//{
//   QUOTE_client(0l);
//    q_client_counter++;
//}
//#
//# //USE_TCPIP_CLIENT 
     
 //    pri//    pri> %ld",ssc1_int_cnt);
     
#ifdef USE_QUOTE_SERVER  
   //  printf("\n\r> %ld",rpac_counter);
#endif //USE_QUOTE_SERVER 
 
  
  
#ifdef TEST_RECEIVE
     if(st_count > 10)
     {
     //     printf("\n\r>%ld %ld nc: %ld", sendp ,delta, receivepb);
          st_count = 0;
          sendp = 0;
          delta = 0;
          receivep = 0;
          receivepb = 0;

          
     }
     else{ /* Body */
         st_count++;
        } /* Endbody */
#endif //TEST_RECEIVE  
  
  
  
#ifdef CHECK_ETH_STATE  
//   printEthLongHex(my_IP_OK);
   my_IP_OK++;
//   printfpd("\n\r %d", my_IP_OK);
  //  printfpd("speed: %d", speed);

 
//101201 test #ifndef PROG_PRM_PCH_N
//#ifndef ZZZ_ZZZZZ //temporary
#ifndef DISABLE_ETHERNET  //101201

 Check_MAC_BNA();
 
#ifdef ETH_CAN_RESTART
// if(1)
  //   printfp("can restart");


#ifdef PING_ENABLED

// printfp("ping enabled");
  //   RTCS_ping(0x9b9b9b97, 0, 1);
  if((my_IP_OK > (ETH_RESTART_TIMEOUT >> 1)) && speed)
  {
  SetTestMode(0x8el); 
  WriteDevId();
  wd_init_short();
     RTCS_ping(GetIP(), 0, 1);
  SetTestMode(0x1); 
   WriteDevId();

  wd_init();   
   }
#endif //TRAP_ENABLED 


//#ifndef TRY_UNBLOCK
 if((my_IP_OK > ETH_RESTART_TIMEOUT) && speed) //temporary
//#else   //  TRY_UNBLOCK
 //if((_task_get_status_from_name ("TCP/IP")) == UNHANDLED_INT_BLOCKED)
//#endif // TRY_UNBLOCK 
// if((my_IP_OK > ETH_RESTART_TIMEOUT)) //temporary
{
 my_IP_OK = 0;
 
 //RestartTest++;
#ifdef DEV_ETH_CAN_RESTART 
//  RestartAutoNeg();
//  #else //  DEV_ETH_CAN_RESTART
 //   printfp(" restart0");

#ifndef TEST_RESTART
//if(rnms_was_used)
if(1)
//if(1)   //t101028
{

 //  printfp(" restart1");

/*
#ifndef USART0_TRY_PDC_1T
printf("\n\r...restart to tcpip");
#else
printfp("\n\r...restart to tcpip ");
#endif
 */
//delay_mcs(100000);
#ifdef  PROG_BMDN1

 RestartTestE++;
 SetTestMode(0x8el); //t101028   //restart rtcs only
 WriteDevId();
 dev_restart();      //t101028

#else 

 // printfp(" restart2");

 SetTestMode(0x8el);  //restart rtcs only
 WriteDevId(); 
 dev_restart(); 
#endif 
}

#ifdef TRY_UNBLOCK
//___________________________________________________
 //____________________________________________ 
  /*
 
  Set_enet_local0((uchar*)&enet_local0[0]);
//#ifndef PROG_PRM_PCH_N  
//    Initialize RTCS 
//#ifndef PROG_PRM_PCH_N   
//#ifndef  DISABLE_ETHERNET
// rtcs_result = RTCS_create();   //1a
// rtcs_result = RTCS_create1();   //1a
rtcs_result = RTCS_create2();   //1a
 
//ok  
//  Install RTCS Applications 
#ifndef USE_TCPIP_CLIENT
#ifndef USE_QUOTE_SERVER

#ifdef USE_TFTPSRV 
 rtcs_result = TFTPSRV_init("TFTP Server", 7L, 2000L);   //2a  //t 
#endif // USE_TFTPSRV
#ifdef USE_SNMP 
 rtcs_result = SNMP_init("SNMP Agent", 7L, 2000L); //3a
  MIB1213_init(); //4a //my
#endif //USE_SNMP  
  
  
#endif
#endif   
//ok
//#ifndef PROG_PRM_PCH_N    
  rtcs_result = ENET_initialize(0, enet_local0, 0x00000000, &enet_handle0); //1b
 // rtcs_result = ENET_initialize3(0, enet_local0, 0x00000000, &enet_handle0); //1b
//ok  
//  if (rtcs_result != ENET_OK) //?? olweis ok?
  //  {
 //     Enet_is_not_init();
 //   } 
    
//#endif  // PROG_PRM_PCH_N 
  printf("\n\r > enet_handle0 : 0x%X",(unsigned long)(enet_handle0));
  
//hier hangt!!!!
   rtcs_result = RTCS_if_add(enet_handle0, RTCS_IF_ENET, &ihandle0);  //2b
//t   rtcs_result = RTCS_if_add1(enet_handle0, RTCS_IF_ENET, &ihandle0);  //2b
   //hier print now rtcs_get_data!!!!!!
   printf("\n\r > rtcs data : 0x%X",(unsigned long)(rtcs_result));
    printf("\n\r > get data : 0x%X",(unsigned long)(RTCS_get_data()));
   
   
   
 //  rtcs_result = RTCS_if_bind(ihandle0, 0x9b9b9b0f, 0x00000000);
//     rtcs_result = RTCS_if_bind(ihandle0, 0x9b9b9b0e, 0x00000000);
 rtcs_result = RTCS_if_bind(ihandle0, GetIP(), 0x00000000);   //3b
//t    rtcs_result = RTCS_if_bind1(ihandle0, GetIP(), 0x00000000);   //3b
    
    printf("\n\r > rtcs data1 : 0x%X",(unsigned long)(rtcs_result));
   
    
   OldIP = GetIP();    
 //  Add Gateways 
 //  rtcs_result = RTCS_gate_add(0x9b9b9b01, 0x00000000, 0x00000000);
//   if (rtcs_result != RTCS_OK)
 //     {
      //     while(1);
      //     State |= 0x40l;
 ///     } 
    //    aic_ptr->ICCR = 0xff;
       
    //      _int_enable();
    
    
    
#ifdef TCPIP_CONNECT
 

#ifndef USE_TCPIP_CLIENT
#ifndef USE_QUOTE_SERVER
  buffer_rad_T_len = 0l;
//100226 not need   rtcs_result = ECHOSRV_init   (taskname = "Echo server",   7, 1500);
//t  rtcs_result = RDNSRV_init   (taskname = "Radian server",   7, 1500);    //port 155
  rtcs_result = RDNSRV_init   (taskname = "Radian server",   7, BUFFER_SIZE_T); //100525 - 2000    //port 155/port 155s_result = RDNSRVT_T_it   (taskname = "Radian transmit",   7, 1500); //now setted my ip address 155.155.115.114
#endif //USE_QUOTE_SERVER
#endif// USE_TCPIP_CLIENT



#endif //TCPIP_CONNECT  
  */

          
//__________________________________________________



  // 101122 : try make new way - to have receiewe with full restart rtcs and dann go 
  //to current task pointers to data to do not loss memory
  /* 101217 
   printf("\n\rrestart task - change status");
   _task_set_status_from_name("TCP/IP", 5);
   _task_set_error_from_name("TCP/IP", 0);
   _task_set_info_from_name("TCP/IP", 16);
   */
 //  ENET_recovery();
   Restart_Eth5();
   
//   ENET_initialize1(0, enet_local0, 0x00000000, &enet_handle0);
     /*
  rtcs_result = RTCS_if_add(enet_handle0, RTCS_IF_ENET, &ihandle0);  //2b
 rtcs_result = RTCS_if_bind(ihandle0, GetIP(), 0x00000000);   //3b
   rtcs_result = RDNSRV_init   (taskname = "Radian server",   7, BUFFER_SIZE_T); //100525 - 2000 
     */
 //  
 // rtcs_result = RTCS_if_add(enet_handle0, RTCS_IF_ENET, &ihandle0);  //2b
 // rtcs_result = RTCS_if_bind(ihandle0, GetIP(), 0x00000000);   //3b
   

 //  _GET_KERNEL_DATA(kernel_data);


     
    // _INT_DISABLE();
  //   _int_disable();   

  // _task_ready_internal(tcpip_id);
  //   _int_enable();   

  // _INT_ENABLE();

   
//_int_disable();   
//_task_abort(tcpip_id);     //not hangt!
//  RTCS_task_exit(TCPIP_task, 0);



//_task_destroy(tcpip_id);   //counter after this work!!!!
//_task_destroy(snmp_id);   //counter after this work!!!!
//_task_destroy(rdn_id);   //counter after this work!!!!
//_task_destroy(tftp_id);   //counter after this work!!!!
//_task_destroy(snmp_id);   //counter after this work!!!!
//_task_destroy(tcpip_id);   //counter after this work!!!!

//  td_ptr = _task_get_td(tcpip_id);
//_int_disable();
//td_ptr->STATE = WAIT_BLOCKED;
//_task_block();
//_int_enable();

//_int_disable();
//if ((td_ptr != NULL) && (td_ptr->STATE == WAIT_BLOCKED)){
//_task_ready(td_ptr);
//}
//_int_enable();

 //();
 
// _task_stop_preemption();//unhandled interrupt
//Set_enet_local0((uchar*)&enet_local0[0]);

// _task_ready(_task_get_td(tcpip_id));   //not hangt but do not work
 //  _task_restart(tcpip_id, NULL, FALSE);
//_int_disable(); 

// for(cnt = 0l; cnt < 32l; cnt++){ 
//     aic_ptr->EOICR = 0xFF; 
//     }

// Set_enet_local0((uchar*)&enet_local0[0]);

// rtcs_result = RTCS_create1(te1( //1a     not hangt!!!!     but not create!
 
 
 // _task_restart(tcpip_id, NULL, TRUE); //?????????
 
//_int_enable(); 
//_task_start_preemption(); 
//#ifndef USE_TCPIP_CLIENT
//#ifndef USE_QUOTE_SERVER

//#ifdef USE_TFTPSRV 
//_task_destroy(tftp_id);
// rtcs_result = TFTPSRV_init("TFTP Server", 7L, 2000L);   //2a  //t 
//#endif // USE_TFTPSRV
//#ifdef USE_SNMP 
//_task_destroy(snmp_id);
// rtcs_result = SNMP_init("SNMP Agent", 7L, 2000L); //3a
//  MIB1213_init(); //4a //my
//#endif //USE_SNMP  
  
  
//#endif
//#endif   
  
//#ifndef PROG_PRM_PCH_N    
//  rtcs_result = ENET_initialize(0, enet_local0, 0x00000000, &enet_handle0); //1b
  
 // if (rtcs_result != ENET_OK) //?? olweis ok?
 //   {
 //     Enet_is_not_init();
 //   } 
    
//#endif  // PROG_PRM_PCH_N 
 //  rtcs_result = RTCS_if_add(enet_handle0, RTCS_IF_ENET, &ihandle0);  //2b
 // rtcs_result = RTCS_if_bind(ihandle0, 0x9b9b9b0f, 0x00000000);
//     rtcs_result = RTCS_if_bind(ihandle0, 0x9b9b9b0e, 0x00000000);
//    rtcs_result = RTCS_if_bind(ihandle0, GetIP(), 0x00000000);   //3b
 //  OldIP = GetIP();   
 //   tcpip_id = _task_get_id_from_name("TCP/IP");
    
 //   _task_ready(_task_get_td(tcpip_id));
 
//#ifndef USE_TCPIP_CLIENT
//#ifndef USE_QUOTE_SERVER
//  buffer_rad_T_len = 0l;
//100226 not need   rtcs_result = ECHOSRV_init   (tasknamsknamEcho server",   7, 1500);
//_task_destroy(rdn_id);
//  rtcs_result = RDNSRV_init   (taskname = "Radian server",   7, 1500);    //port 155
//  rtcs_result = RDNSRV_init   (taskname = "Radian server",   7, BUFFER_SIZE_T); //100525 - 2000    //port 155/port 155s_result = RDNSRVT_init   (taskname = "Radian transmit",   7, 1500); //now setted my ip address 155.155.115.114
//#endif //USE_QUOTE_SERVER
//#endif// USE_TCPIP_CLIENT
 
 //   	my_int_enable_usart0();

 //  _task_start_preemption();
 //_int_enable();

//Restart_Eth();

 // _task_restart(tcpip_id, NULL, TRUE);  //after this hangt
//_task_abort(taska_id);
// _task_ready(_task_get_td(snmp_id));
 // _task_ready(_task_get_td(tcpip_id));  //after this
#endif   //try unblock

  
#else  //no test restart
//#ifdef TRY_UNBLOCK

//else
//{
// printf("\n\r my_IP_OK: %d speed : %d", my_IP_OK, speed);    //
//}
//#endif  //tets

  
//  _task_restart(_task_id task_id,uint_32_ptr param_ptr,boolean blocked)
//  _task_restart(tcpip_id, NULL, FALSE);
//  _task_restart(0x10003, NULL, TRUE);
//   Restart_Eth4();
//   Restart_Eth1();    //counter is restarted but do not work
 // printf("\n\r td:0x%X" ,_task_get_td(0x10003));
//  _task_ready(_task_get_td(0x10003));
//   Restart_Eth3(); 
#endif //no testrestart 
//else
//{
// printf("\n\r my_IP_OK: %d speed : %d", my_IP_OK, speed);    //
//}


#endif //DEV_ETH_CAN_RESTART
// Restart_Eth();
}
//_______________________101028
//else
//{
// printf("\n\r my_IP_OK: %d speed : %d", my_IP_OK, speed);    //
//}
//_______________________101028




#ifndef TEST_RESTART

#ifdef TRY_UNBLOCK

else
{

#ifndef USART0_TRY_PDC_1T
 
printf("\n\r my_IP_OK: %d speed : %d", my_IP_OK, speed);    //
printf("\n\r TCPIP status: 0x%X",_task_get_status_from_name ("TCP/IP"));
printf(" TCPIP error: 0x%X",_task_get_error_from_name ("TCP/IP"));
//printf(" TCPIP flags: %d",_task_get_flags_from_name ("TCP/IP"));
//printf("\n\r TCPIP task_sr: %d",_task_get_task_sr_from_name ("TCP/IP"));
//printf(" TCPIP task_info: %d",_task_get_info_from_name ("TCP/IP"));
 printf("\n\r Stephany0: %d 1: %d 2 : %d 3:%d",Stephany0,Stephany1,Stephany2,Stephany3);
 printf("\n\r ul_pointer_bd: %d tcpipmsgcnt: %d",ul_pointer_bd, tcpipmsgcnt);
 printf("\n\r ul_counter_bd: %d ",ul_counter_bd);
 printf("\n\rihandle0 : 0x%X",(unsigned long)(ihandle0));
 printf(" get data : 0x%X",(unsigned long)(RTCS_get_data()));
 printf(" enet_handle0 : 0x%X",(unsigned long)(enet_handle0));  
 printf("\n\r keephandle : 0x%X",(unsigned long)(keephandle));
 printf("\n\r keephandle2 : 0x%X",(unsigned long)(keephandle2));
 printf("\n\r keephandle3 : 0x%X",(unsigned long)(keephandle3));
 printf("\n\r keep_ip_cfg : 0x%X",(unsigned long)(keep_ip_cfg));
 printf("\n\renet_ptr->FEC_RING_PTR->RX_RING : 0x%X",(unsigned long)( Get_ENET_Data(0, enet_local0, 0x00000000, &enet_handle0)));
#endif //USART0_TRY_PDC_1T  
}
#endif  //try_unblock
#endif  // no test_restart

#endif //ETH_CAN_RESTART 
#endif //CHECK_ETH_STATE
#endif //PROG_PRM_PCH_N

  
#ifdef 	TEST_RDN
//printEthLongHex(crdn + carp + cip);
// printf("\n\r crdn = %ld carp= %ld cip = %ld ", crdn, carp, cip);
#endif //TEST_RDN
  
  
  
#ifdef PROG_PRM_PCH_C
 #ifndef PROG_PRM_PCH_S
  #ifndef PROG_PRM_PCH_N

   CheckPower();
   
 //  print_signature(); //for test
  #endif // PROG_PRM_PCH_N
 #endif //PROG_PRM_PCH_S  
#endif // PROG_PRM_PCH_C
  //  print_signature(); //for test

  
//#ifdef PRINT_YOURNAL
 //  printfpd("\n\r addr : 0x%lX", addr);
//	 printEthLongHex(time1);
//#endif

  
  
  
  
#ifdef CLOCK_ENABLED
  UpdateClock();
#endif //CLOCK_ENABLED


  
  
 // printEmb(); //t
// m_Test_PKU(); //t 
//  Ring(1,1,5,1);  //t
#ifdef TRAP_ENABLED
    SendTrap(1);
#endif //TRAP_ENABLED 

//#ifdef PING_ENABLED
  //   RTCS_ping(0x9b9b9b97, 0, 1);
 //    RTCS_ping(GetIP(), 0, 1);
//#endif //TRAP_ENABLED 


  
   
#ifdef ETH_DEBUG_ENABLED
 // printEthString("Hello!\n\r"r"8);
//  printEthString("Hello\r\n", 10);   //ok

 // printEthLongHex(CheckDoneShort());
 // printEthLongHex(pinger);
// printEthLongHex(GetRemoteMode());
 //  printEthByteHex(0x21);  //ok

#endif //ETH_DEBUG_ENABLED
  pinger = 0;
//  printEthLongHex(Stephany7); 
//  printf("\n\r %lX",Stephany7);
  //t      aic_p_p->EOICR = 0xFF;    //to com from spurious interrupt if it go
  // ARP_request(ihandle0, GetIP(),0x9b9b9b9D );  //to test
  // RDN_request(ihandle0, GetIP(),0x9b9b9b9D );  //to test
//t1103   RDN_transmit(ihandle0,  RDN_BufferT, enetdest);  //temporary  //?? can not use pointers - can use names of buffers in future     
#ifndef PROG_TUTS   
#ifndef WITHOUT_XILINX  
//not need!   CheckDone();
//#else //PROG_TUTS
//   Inputs_Monitoring();
#endif // WITHOUT_XILINX
#endif // no PROG_TUTS
#ifndef USE_TCPIP_CLIENT
#ifndef USE_QUOTE_SERVER

#ifndef DO_NOT_CHECK_ETH_RATE
//101201 t#ifndef PROG_PRM_PCH_N 
//#ifndef ZZZ_ZZZZZZZ 
#ifndef DISABLE_ETHERNET  //101201


#ifndef TEST_SLOW
  Support_Ethernet_10MBit(); 
#else
  SetLink10();  
#endif //TEST_SLOW 
 
#endif //PROG_PRM_PCH_N 
#endif //USE_QUOTE_SERVER
#endif // USE_TCPIP_CLIENT
#endif // DO_NOT_CHECK_ETH_RATE
//   PrintMessages();
   
#ifdef PROG_DTVM
  FillSynceVersion2();
#endif //  PROG_DTVM 

#ifdef PROG_PU_M_MUX_TEST
  CompareRegs();
#endif //PROG_PU_M_MUX_TEST

#ifdef USART0_TRY_PDC
if(GetTestMode() == 0x50)
{
   PrintTestBuf(); 
}
#endif //USART0_TRY_PDC
   
   
    //t
//      printf(">>>\n\r %0X \r" ,inportb(0x5a6));
//printf("\n\r Stephany19 : 0x%lX ", Stephany19);
  
     
//  testWrite(); //for test!!!
   
//#ifndef PRM_PCH_N 

//#ifndef	 PROG_PRM_PCH_SPI_XIL
   if(led)
   {
   pio_ptr1->CODR = tg; //(1<<pin);
   led = 0;
  // TUTS_Output_Set(0);
  //  send485_enabled = 0;
  //  printfp("1");

   }
  else
   {
   led = 1;
   pio_ptr1->SODR = tg; //(1<<pin);
 //   send485_enabled = 1;

 //   TUTS_Output_Set(0xff);
//   printfp("0");
   }
     
//#endif     
//#endif //PRM_PCH_N     

//   cnt = 0;
 //  Stephany6 =  TimerCounter;
#ifdef PROG_PRM_PCH_N_1 
#ifdef TEST_PRM_PCH_1

//Init_SSC1();

 	for(long i = 0; i < SSC1_RECEIVE_SIZE; i ++)
			{
	  		  SSC1_BUFFER_RECEIVE[i] = 0;
			}




need_to_sended =  MESSAGE_LEN;



 OperateSynt(0);
#ifndef USART0_TRY_PDC_1T 
 printf("\n\r> %ld : %02X  %02X  %02X  %02X  %02X ",ssc1_int_cnt,SSC1_BUFFER_RECEIVE[0],  SSC1_BUFFER_RECEIVE[1],SSC1_BUFFER_RECEIVE[2],SSC1_BUFFER_RECEIVE[3],SSC1_BUFFER_RECEIVE[4]); 
#endif
#endif //  TEST_PRM_PCH_1
#endif //PROG_PRM_PCH_N_1 


#ifdef USE_SOCKETSD	

#ifdef UDP_DEBUG

   flag_send_udp_asu = 1; //t
#endif   
#endif    
 
 
 
 Stephany6 =  pinger;
 

 
 }       //_________________PINGER
 
 //_______________________________________________ test of time

/* 
  if(led)
   {
   pio_ptr1->CODR = tg; //(1<<pin);
   led = 0;
  // TUTS_Output_Set(0);
  //  send485_enabled = 0;
   
   }
  else
   {
   led = 1;
   pio_ptr1->SOD>SODtg; //(1<<pin);
 //   send485_enabled = 1;

 //   TUTS_Output_Set(0xff);
   }
*/  
 
//#endif //PRM_PCH_N   
   
//   if((time1 -  Stephany19) > 5000) //5sec
//   { 
 
//   Stephany19 = time1;
//   printf("\n\r Stephany19 : %ld ", Stephany19);

//   }
   
 //________________________________________________
/* 
#ifdef PROG_MD310 
if (modem_bytes_time > time1) 
{
   modem_bytes_time = time1;
}
 
 
if (modem_bytes_time < time1) 
{
   modem_bytes_time = time1;
   modem_bytes_counter = 0;
}

if (transit_bytes_time > time1) 
{
   transit_bytes_time = time1;
}

if (transit_bytes_time < time1) 
{
   transit_bytes_time = time1;
   transit_bytes_counter = 0;
}

#endif
  */

 
#ifdef IRQ_LIMITED 
 if(time_irq < time1)
 { /* Body */

  time_irq =   time1 + LIMIT_IRQ_PERIOD;
  /*
  printEthLongHex(InterruptWatchDog);
    InterruptWatchDog = 0;   //for test
     */
#ifndef PROG_TUTS   
    //  printEthLongHex(InterruptWatchDog);

 //if(InterruptWatchDog == INTERRUPT_WAIT)
// if(InterruptWatchDog >= INTERRUPT_WAIT)    //100813
// { 
#ifndef WITHOUT_INTERRUPTS
//100813 error!!!   EnableInterrupts();

 // printEthLongHex(InterruptWatchDog);
 //  printfpd(">>%d <<", InterruptWatchDog);
//_______________________________________________100813_
//   if (IntFlag)
 //  {  
     my_int_enable_irq0(); 
 //  IntFlag = 0; 
 //  }
   InterrnterrtchDog = 0;

//________________________________________________100813
#endif //WITHOUT_INTERRUPTS   
 //  SetBufferState((unsigned long)INTERRUPT_OVERFLOW);
// }
// else
// {
//   InterruptWatchDog = 0;
// }
#endif //no PROG_TUTS  
}

#endif  //IRQ_LIMITED 


 
#ifdef PROG_TUTS 
   Inputs_Scan();
 
#endif // PROG_TUTS 
//}

//#endif  //IRQ_LIMITED 


#ifdef USART1_TRY_PDC
#ifndef PROG_PRM_PCH_N
 timer++;
#endif //PROG_PRM_PCH_N

if((time_pdc_u1 < timer)&& ((timer - time_pdc_u1) > PDC_PERIOD))
{
//printfp("_._");
 OperateBuffers_usart1();  
  time_pdc_u1 = timer;
}
if(time_pdc_u1 > timer)    //going from zero timer
{
 time_pdc_u1 = timer;  
}

 
#endif //USART1_TRY_PDC

#ifdef USART2_TRY_PDC
#ifndef PROG_PRM_PCH_N
// timer++;
#endif //PROG_PRM_PCH_N

if((time_pdc_u2 < timer)&& ((timer - time_pdc_u2) > PDC_PERIOD2))
{
 OperateBuffers_usart2();  
  time_pdc_u2 = timer;
}
if(time_pdc_u2 > timer)    //going from zero timer
{
 time_pdc_u2 = timer;  
}

 
#endif //USART2_TRY_PDC






#ifdef USART0_TRY_PDC_1
 
if((time_pdc_u0 < timer)&& ((timer - time_pdc_u0) > PDC_PERIOD))
{
 OperateBuffers_usart0();  
  time_pdc_u0 = timer;
}
if(time_pdc_u0 > timer)    //going from zero timer
{
 time_pdc_u0 = timer;  
}

 
#endif //USART0_TRY_PDC_1

#ifdef USART0_TRY_PDC_1T
 
if((time_pdc_u0t < timer)&& ((timer - time_pdc_u0t) > PDC_PERIOD_T))
{
 OperateBuffers_usart0t();  
  time_pdc_u0t = timer;
}
if(time_pdc_u0t > timer)    //going from zero timer
{
 time_pdc_u0t = timer;  
}

 
#endif //USART0_TRY_PDC_1

#ifdef USART1_TRY_PDC_1T
 
if((time_pdc_u1t < timer)&& ((timer - time_pdc_u1t) > PDC_PERIOD_T1))
{
 OperateBuffers_usart1t();  
  time_pdc_u1t = timer;
}
if(time_pdc_u1t > timer)    //going from zero timer
{
 time_pdc_u1t = timer;  
}

 
#endif //USART1_TRY_PDC_1

#ifdef USART2_TRY_PDC_1T
 
if((time_pdc_u2t < timer)&& ((timer - time_pdc_u2t) > PDC_PERIOD_T2))
{
 OperateBuffers_usart2t();  
  time_pdc_u2t = timer;
}
if(time_pdc_u2t > timer)    //going from zero timer
{
 time_pdc_u2t = timer;  
}

 
#endif //USART2_TRY_PDC_1

 //my_int_disable_usart0();//t
 // pio_ptr1->CODR = tg; //t
 // _int_enable();  //090325
 //____________________________________________
 //  if(_io_fstatus(fusart0_ptr)){ 
   //             printf(">\n\r %c", fgetc(fusart0_ptr));
     //        } 
 //____________________________________________
 
  // ENET_unlock(); 

//  my_int_t_able_eth(); //t0624



 //ENET_SCAN(enet_handle0);

//#ifndef PROG_PRM_PCH_N  
//_int_disable();
//delay_mcs(200000); //t100524
//_int_enable();
// pio_ptr1->SODR = tg;   //t
//Disable_irqs_for_task();
//#ifdef PROG_MD310
//  my_int_disable_irq0(); 

//printfp("1");
   
//#endif     
 _time_delay_ticks((_mqx_uint)1);
//#endif //PROG_PRM_PCH_N 
 
 
}  
} 
/* End of File */
